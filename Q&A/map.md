Мапа
==============================

Что такое мапа?

 Мапа это хэштаблица, она хранит пары "ключ-значение", где каждому уникальному ключу соответствует определенное значение
 Ключи в мапе должны быть сравнимыми типами, например string, int, bool...

 Бакет(Bucket/Slot) - cтруктура данных, в которой хранятся ключи, значения и топхеш . Данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов

==============================

Что произойдет при конкуррентной записи в мапу? 

 Мапа не безопасна для конкурентного использования. 
 При работе с мапой в конкурентном режиме, в частности, при записи, возникнет состояние гонки. Это состояние, когда несколько потоков пытаются получить и обновить одни и те же данные. Чтобы предотвратить состояние гонки, нужно заблокировать общие данные так, чтобы только одна горутина имела возможность обновлять данные в данный момент времени, а при чтении горутинами ни одна не могла ничего записать в мапу в текущий момент.

 Для решения проблемы состояния гонки используется объект RWMutex, который при записи блокирует код для остальных горутин на время выполнения операций, затем в конце функции (с помощью defer) разблокирует. При чтении он блокирует только то место, где происходит запись.
--------------------------------------------------------------------------------

Как устроена мапа под капотом?

 Тип map в Go представляет собой ассоциативный массив или словарь, который состоит из набора пар ключ-значение. Ключи и значения могут быть любого типа, но все ключи должны быть одного типа, и все значения должны быть одного типа.

 Внутри себя, map реализован как хэш-таблица, что обеспечивает эффективный доступ к значениям по ключу. Хэш-таблица является структурой данных, которая использует хэш-функцию для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.

 Порядок элементов в map не гарантирован и может меняться при каждой итерации по map
--------------------------------------------------------------------------------

Какие ключи могут быть у мапы?

 В качестве ключа можно использовать любой тип данных для которого определена операция сравнения. Ключи в мапе должны быть сравнимыми типами, например string, int, bool... Например, можно использовать структуру с тем же условием для всех ее полей.
 
 При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу
--------------------------------------------------------------------------------

Какая сложность работы с мапой?

 O(N) -----Что еще сюда добавить?-----
--------------------------------------------------------------------------------

Можно ли взять адрес элемента мапы и почему?

 Нельзя получить адрес элемента. Потому что при росте мапы оно переедет в другой бакет и адрес у него, соответственно, поменяется

==============================

Как разрешаются коллизии в мапе?
--------------------------------------------------------------------------------

Как сделать конкурентную запись в мапу?
--------------------------------------------------------------------------------

Как достигается константная сложность работы с мапой?
--------------------------------------------------------------------------------

В функции make для мапы мы указываем число. Что оно дает?
--------------------------------------------------------------------------------
Для чего используется мапа?
--------------------------------------------------------------------------------
Мапа потокобезопасная?
--------------------------------------------------------------------------------
Пробовали из разных потоков писать в мапу?
--------------------------------------------------------------------------------
Стало слишком много коллизий в мапе, как решить проблему?
--------------------------------------------------------------------------------
Какая сложность работы с мапой в худшем случае?
--------------------------------------------------------------------------------
Что произойдет при конкуррентном чтении из мапы?
--------------------------------------------------------------------------------
Чем мапа отличается от sync.Map?





5. Как работает эвакуация данных?
 Она начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.

 Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
 Именно поэтому в структуре мапы есть свойство B — это степерь двойки, которая показывает кол-во бакетов.

 Во время эвакуации данных, все операции мапы остаются доступны. Поэтому во многих частях исходного кода есть обращения как к buckets, так и к oldbuckets. После завершения копирования данных, oldbuckets становится равно nil.






Другие особенности map

 - Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;

 - При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;

 - При коллизиях используется стратегия сlosed addressing. Мы перебираем все ячейки бакета (их 8) и ищем первое свободное место;

 - OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.

 - При росте элементы переносятся в новые бакеты постепенно, а не все сразу






