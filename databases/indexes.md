GIN, GIST - полнотекстовый поиск или пространственные данные
BRIN - массивные временные ряды

**HASH**
Хэш индекс использует хэш функцию. Эта функция отображает тип данных в 32-битное целое число - хэш-код. Хорошая хэш-функция раскидывает вычисляемые значения равномерно по всему доступному диапазону (всего около 4 миллиарда значений).

Хэш-код в свою очередь отображается в номер одного из т.н. бакетов. А в бакетах хранится непосредственно маппинг данного хэш-кода на соответствующие строки таблицы.

Простейшая хэш-функция для входящих целых чисел это деление по модулю. Делим число А на число Б и остаток от целочисленного деления считаем хэш-кодом. Например, чтобы раскидать числа по трем бакетам, используем функцию mod(3)

Когда новое значение добавляется в индекс, система применяет к нему хэш-функцию и помещает хэш-код и указатель на кортеж в бакет.
Когда вы выполняете поиск, система берет значение, вычисляет хэш-код, находит нужный бакет, находит ссылку на нужные кортежи.

PostgreSQL использует специальные хэш-функции, которые гарантируют, что значения в бакете могут быть разделены ровно на два бакета. При разделении бакета для индекса выделяется дополнительное хранилище.

Хэш-индексы не рекомендовались к применению до 10 версии PostgreSQL. Если почитаете доки по индексам версии 9.6, то увидите прямое предостережение. Проблема была в том, что хэш-индексы не записывались в WAL - а значит не могли быть использованы в репликах и не восстанавливались автоматически после крэшей. В версии 10 эти проблемы были устранены

***Отличия индексов хэш и b-tree***
-Хэш индекс занимает меньше места, чем b-tree
-Хэш индекс растет инкрементально. В отличие от b-tree, растущего линейно по мере добавления строк, хэш растет рывками. Это происходит в моменты инциализации разделения индекса и аллокации дополнительной памяти под бакеты.
-Хэш индекс не зависит от размеры индексируемого ключа. Хэш-индекс хранит хэш-коды (целые числа), а b-tree индекс хранит собственно значения.
-Хэш-индекс не зависит от селективности индексируемого значения. Селективность столбца url отличается от селективности столбца key (который гораздо более уникален)

***Параметр fillfactor*** влияет на механизм разделения хэш-индеса. Он определяет соотношение между хранимыми ссылками на кортежи и количеством бакетов. Чем меньше fillfactor, тем более "пустое" пространство в индексе.
Для b-tree это параметр по умолчанию 90, для хэш-индекса - 75

Меньший fillfactor заставляет бакеты делиться раньше, что приводит к большему общему размеру. В отличие от b-tree, который резервирует место под обновляемые строки, новые значения в хэш-индесе могут попасть в любой бакет.

Множество индексов хотя и ускоряют операции чтения, но имеют противоположный эффект при операциях записи.

***Ограничения хэш индекса***
Хэш-индекс не может быть использован для организации уникального индекса
Хэш-индекс не может быть использован для составных индексов на несколько столбцов
Хэш-индекс не поддерживает сортировку
Хэш-индекс не годится для поиска по интервалам
Хэш-индекс не дружит с ORDER BY

***Итог***
Хэш-таблицы - очевидный выбор, когда нужен быстрый поиск данных по ключу. Однако нюансы реализации хэш-индексов до 10 версии PostgreSQL заставили DBA и разработчиков забыть о таком механизме.

Но что мы имеем в свежих версиях:

Хэш-индекс был доработан и теперь абсолютно продакшн-реди.
Хэш-индекс как правило занимает меньше места, чем аналогичный b-tree.
Хэш-индекс незначительно выигрывает в производительности как при вставке, так и при чтении.

