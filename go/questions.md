# Типы данных
-------------
- Логический(bool), Целочисленные типы, Числа с плавающей запятой, Строковые типы, Указатели, Идентификационные типы, Абстрактные типы данных

## String
--------------------------------
- представляет собой неизменяемую последовательность байтов, массив хранящий внутри коды символов (55 - А, 77 - Z). Для изменения или конкатенации большого количества строк следуюет использовать StrginBuilder/ByteBuilder
- руны позволяют работать с символами Unicode. Руна в Go — это тип данных, представляющий собой один символ Unicode. Он эквивалентен типу int32 и используется для представления символов, которые могут занимать более одного байта в строке. Руна позволяет работать с символами, которые могут быть представлены в различных кодировках, включая кириллицу, иероглифы и другие.
- У каждой кодировки есть размер символа и методика шифрования. Через это можно определить какие символы в строке
  
## Map
-------------
- Мапа это хэштаблица, которая хранит пары "ключ-значение", где каждому уникальному ключу соответствует определенное значение
- Ключи в мапе должны быть сравнимыми типами, например string, int, bool...
- под капотом хэш-функция для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.
- Бакет(Bucket/Slot) - структура данных, в которой хранятся ключи, значения и топхеш . Данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов
- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу

### Работа с map
- Мапа не потокобезопасна, но есть sync.Map (под капотом  RWMutex). При работе с мапой в конкурентном режиме, в частности, при записи, возникнет состояние гонки (race condition)
- Брать адрес элемента мапы не рекомендуется, тк это нарушит целостность данных - мапа не потокобезопасна (возможны ошибки - значение переместиться в другой участок памяти (бакет) или память вообще будет высвобождена и будет out of bounds)
- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;
- для удаления элемента вместо фактического удаления просто ячейка помечается пустой (0, nil)

### эвакуация данных в map
- Она начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.
- Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
Именно поэтому в структуре мапы есть свойство B — это степень двойки, которая показывает кол-во бакетов.
- Во время эвакуации данных, все операции мапы остаются доступны. Поэтому во многих частях исходного кода есть обращения как к buckets (новая структура бакетов, где их становится в 2 раза больше от текущего), так и к oldbuckets (текущение значение указателя buckets). После завершения копирования данных, oldbuckets становится равно nil.
- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.
- При росте мапы элементы переносятся в новые бакеты постепенно, а не все сразу

### сложность работы с map
- В лучшем случае - О(1), в худшем - О(n) (зависит от количества коллизий/хеш функции)
- константная сложность работы с мапой достигается за счёт хеш-таблицы

### коллизии в map
- Так как хэш-функция не идеальна, передав в нее два разных значения можно получить один и тот же результат. В случае с бакетами если - два разных значения положить в один и тот же бакет. 
- разрешение коллизий - выбирается один и тот же бакет и если происходит коллизия - создаётся новый бакет, который прилинковывается к первоначальному (аналог связного списка).
- как вариант, при большом количестве коллизий в мапе, можно переопределить хеш функцию у своих сравнимых структур ключа
- При коллизиях используется стратегия сlosed addressing (элементы хранятся с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, массив и др)

## Слайс
--------------------------------
- **является ссылочным типом**
- слайс это динамическая структура данных (может изменять свою длинну), надмножество массивов. Слайс создает массив, и при надобности расширяет его
- слайс под капотом содержит указатель на исходный массив, каписити(емкость) и длину(количество элементов заданного типа)
- используется для хранения динамически меняющих свой размер массивов данных
- слайс не потокобезопасен

### Работа со слайсом
- append - В зависимости от текущих len/cap либо дописывает значение в текущий массив (возможна перезапись), либо создаёт новый массив х2 размера + подменяет указатель в слайсе + дописывает значение в новый массив
- Всегда передавать указатель на слайс, потому что может произойти пересоздание внутреннего массива и потеря указателя
- Нет полноценного удаления - по факту мы пересоздаём слайс меньшей длинны. А высвобождение данных лежит на исполнителе
- при создании слайса, если явно не указывать массив, который он будет использовать, Go выделяет память для него в куче. go tool compile -m
- сложность - O(n) - идёт полный перебор
- Если несколько горутин используют один и тот же слайс (например, передавая его между собой), то они могут избежать лишних аллокаций памяти. Вместо того чтобы создавать новые слайсы и массивы для каждой горутины, вы можете использовать один и тот же слайс, что экономит память и уменьшает нагрузку на сборщик мусора. Для предотвращения гонок данных можно использовать синхронизацию (например, мьютексы) или каналы для безопасного обмена данными между горутинами.
- если при увеличении слайса полностью забьется память будет out of memory

## Массив
-------------
- Массив имеет фиксированный размер и имеет фиксированное количество элементов. 
- Используется для хранения значений при условии что мы ГАРАНТИРОВАНО знаем что количество не будет меняться
- выделение памяти - при компиляции программы будет происходить escape анализ, при объявлении массива, память для него выделяется на стеке (если массив небольшой) или в куче (если массив большой или передается в функции).
- *передача по значению* в отличие от слайса, который является ссылочным типом
- Последовательный сегмент в памяти в каждой из ячеек которого (размер ячейки зависит от типа данных) хранятся значения. По факту массив - это указатель на начало последовательного сегмента, а обращение к каждой из его ячеек - это приплюсовывание к начальному указателю номера ячейки*размер.

## Каналы
-------------
![image](https://github.com/user-attachments/assets/81b1ed70-72e4-4eea-82ce-46cd306a336a)
- **является ссылочным типом**
- Канал - структура, созданная для передачи данных между горутинами. 
- Под капотом - ёмкость, список читателей, список писателей, буфер для обмена данными (1 в случае небуф, n в случае буферизованного).
- Буферизованые и небуферизованые. Однонаправленые и двунаправленые
- буферизованные - для пересылки массивов данных
- небуферизованные - для пересылки событий

### Чтение и запись в канал
- для неблокирующего чтения из канала используется select/range
- При чтении из закрытого канала будут считываться записанные значения, а когда они закончатся - дефолтные значения в зависимости от объявленного типа канала (в случае int-0, string-"")
- можно считать факт наличия значений в канале и проверить, закрыт канал или нет 
```
value, ok := <-ch
	if !ok {
	// Если ok == false, значит канал закрыт
	fmt.Println("Канал закрыт")
	break
}
```
- операции с каналами: запись, чтение, закрытие (close), создание (make)
  
### небуферизованный канал
- При чтении из небуферизованого канала - будет происходить копирование значения между стеками горутин, которые читают/пишут.
- небуферизованый канал будет блокировать пишущие в него потоки пока ячейка для значения не опустошится (другая горутина не считает) для записи

### буферизованный канал
- При чтении из буферизованого канала - будет происходить чтение из кучи, где размещён обменный массив канала, куда горутины будут ходить
- буферизованный канал не блокирует пишущие в него потоки

## Интерфейс/interface{}
-------------
- Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. Даже пустой интерфейс НИКОГДА не будет nil
- используется для уменьшения связанности кода

### интерфейс в работе
- В месте где объявляется обьект реализующий функционал объявляю интерфейс, в него добавляю все методы которые могут потребить извне. В месте где требуется такой объект опять объявляю интерфейс с нужными мне методами и работаю не с объектом а с интерфейсом. 
- функцию, которая работает с разными типами - switch type
- пустой интерфейс нужен для полиморфизма (изменения работы программы в зависимости от разных входящих параметров)
- any был добавлен для повышения удобства работы с кодом, но в функциональном плане он идентичен пустому интерфейсу 

### пустой интерфейс
- Пустой интерфейс может содержать значения любого типа
- пустой интерфейс требует больше памяти, чем пустая структура, так как он хранит информацию о типе и значении
- Пустой интерфейс используется для работы с разными типами данных

## структура/struct{}
-------------
- Тип struct в Go — это мощный инструмент для организации и управления данными. Он позволяет создавать сложные структуры данных, определять методы и управлять состоянием объектов. Структуры являются основным строительным блоком для создания более сложных типов данных и являются важной частью парадигмы программирования на Go.
- тип struct представляет собой составной тип данных, который позволяет объединять различные типы данных в одну логическую единицу. Структуры используются для создания сложных типов, которые могут содержать несколько полей, каждое из которых может иметь свой собственный тип. Это мощный инструмент для организации и управления данными.
- в Go вы можно определять методы для структур, что позволяет вам привязывать функции к типам данных. Методы определяются аналогично функциям, но с указанием типа структуры в качестве принимаемого параметра:
- Вложенные структуры. Структуры могут содержать другие структуры в качестве полей, что позволяет создавать сложные структуры данных
- В Go можно создавать анонимные структуры, которые не имеют имени
- Структуры могут быть сравнены, если все их поля также могут быть сравнены. Это означает, что вы можно использовать оператор == для сравнения двух структур

### пустая структура
- это специальный тип, который не содержит никаких полей (не может содержать никаких данных). Используется в различных сценариях, таких как маркеры, ключи в мапах и сигналы в контексте
- пустая структура занимает 0 байт в памяти. Это делает её полезной в ситуациях, когда  нужно создать тип, который не требует хранения данных, но всё равно может быть использован в качестве типа.
- Пустые структуры могут быть сравнены друг с другом. Например, две переменные типа struct{} считаются равными, если они обе пустые.
- может использоваться для сигнализации о завершении работы горутины или для синхронизации
- может использоваться для реализации интерфейсов, если  не нужно хранить данные, но нужно иметь возможность передавать тип:

# конкурентность и параллельность в Golang
-------------
- GMP модель, планировщик, каналы, горутины, пакет sync

## пакет sync
-------------
- пакет sync хранит потокобезопасные структуры данных и примитивы сихнронизации потоков
  
### Atomic
- используется для ожидания выполнения горутин
- позволяет предоставить N горутин для доступа к общему ресурсу

### Mutex 
- позволяет организовать доступ к коду одновременно только одной горутине на запись
- контроль доступа к коду

### RWMutex
- обеспечивает контроль доступа к данным
- используется когда нужно разделить операции на читающие/записывающие
- при использовании на читающие не будет происходить блокировки

### WaitGroup
- используются для ожидания выполнения горутин wg.Wait()
- Ожидание выполнения параллельных задач (например обращение к 3 репозиториям)
- Под капотом счётчик который уменьшается/увеличивается через Add/Done

### lock

### sync.Map
- потокобезопасная мапа
- используется в специфических кейсах с использованием 200+ горутин, идет выигрывание по скорости
- map под капотом RWMutex
- sync.Map начинает выигрывать в производительности от 4 ядер

### Pool

### Semaphore 
- позволяет организовать доступ к коду одновременно нескольким горутинам на запись
- позволяет предоставить N горутин для доступа к общему ресурсу

## Горутины
-------------
- Это абстракция над потоками и процессорами в рамках которой мы исполняем наш код.
- Горутина может находиться в трех (основных) состояниях:
- Waiting: В этом состоянии, горутина бездействует. Например встает на паузу для операции с каналами или блокировками, либо может быть остановлена системным вызовом.
- Runnable: Горутина готова к тому чтобы быть исполненной, но еще не исполняется. Она ожидает своей очереди на потоке (M).
- Running: Горутина исполняется на потоке (M). Это будет продолжаться, пока работа не будет выполнена, или до тех пор, пока ее не прервет планировщик, либо что‑то еще ее не заблокирует.
- Горутины НЕ используются единожды и потом выбрасываются.
- Когда новая горутина инициируется, планировщик Go обращается к пулу горутин чтобы забрать одну, и если ни одной нет, то создает новую. Эта новая горутина добавляется в исполняемую очередь процесора (P).
- преимущество горутин над тредами в том, что тред занимает больше памяти, горутина более лековесна. Тред управляется ядром системы, горутина - планировщиком GoLang
- нужны для поддержания большого кол-ва соединений на сервере и более легковесного переключения контекста
- горутина остановится через 10мс после начала выполнения. Также можно передать в горутину объект контекста и задать TimeOut либо вызвать на этом объекте Cancel (ещё можно панику кинуть)
- утечка горутины возникает, когда не закрывается внешнее взаимодействие (например файловый дескриптор)
- горутины общаются между собой через каналы, внешние системы (шины данных или loopback порт)


## GMP(PGM) модель
-------------
- P (processor) - логический процессор (не железо). Это условный контекст, который объединяет поток операционной системы (M) и очередь горутин. Количество горутин, привязанных к P неограниченно. По умолчанию количество P берётся из значения переменной среды GOMAXPROCS и равно количеству логических ядер компьютера
- M (machine thread) - поток OS. Он закреплён за P и имеет с ним отношение один к одному
- G (goroutine) - горутина

### локальная и глобальная очередь
- В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (Global Run Queue - GRQ) и локальная очередь выполнения (Local Run Queue - LRQ). Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.
GRQ предназначен для горутин, которые еще не были назначены для какого-либо P.
- Глобальная и локальная очереди в модели GMP языка Go позволяют эффективно управлять конкурентностью и параллелизмом, минимизируя накладные расходы на синхронизацию и обеспечивая высокую производительность. Это делает Go особенно подходящим для разработки высокопроизводительных и масштабируемых приложений

### Глобальная очередь
- Определение: Глобальная очередь — это очередь, в которой хранятся все горутины, ожидающие выполнения. Она доступна для всех потоков и используется для управления горутинами, которые не были назначены на выполнение
- Использование: Когда горутина создается, она помещается в глобальную очередь. Если локальная очередь потока пуста, планировщик может взять горутину из глобальной очереди и назначить ее на выполнение
- Проблемы: Глобальная очередь может стать узким местом, если много горутин ожидают выполнения, так как доступ к ней требует синхронизации, что может привести к накладным расходам

### Локальная очередь
- Определение: Локальная очередь — это очередь, которая принадлежит конкретному потоку (OS thread). Каждая горутина, запланированная на выполнение в этом потоке, добавляется в его локальную очередь
- Использование: Когда планировщик назначает горутину на выполнение, он сначала проверяет локальную очередь. Если в локальной очереди есть горутины, они будут выполнены без необходимости обращения к глобальной очереди. Это уменьшает накладные расходы на синхронизацию и повышает производительность
- Преимущества: Локальные очереди позволяют уменьшить конкуренцию за ресурсы и ускоряют выполнение горутин, так как потоки могут обрабатывать свои локальные очереди без блокировок

### Принцип работы
- Создание горутин: Когда вы создаете новую горутину, она помещается в глобальную очередь.
- Планирование: Планировщик проверяет локальные очереди потоков. Если локальная очередь пуста, он берет горутину из глобальной очереди и помещает её в локальную очередь потока.
- Выполнение: Поток выполняет горутины из своей локальной очереди. Если он завершает выполнение всех горутин в своей локальной очереди, он снова обращается к глобальной очереди для получения новых задач.
- Устранение блокировок: Если горутина блокируется (например, ожидает на канале), планировщик может переместить другую горутину из локальной или глобальной очереди для выполнения в этом потоке.

# преимущества и недостатки Golang
-------------
- Go используется для разработки высокопроизводительных серверных приложений и микросервисов
- последняя версия Golang 1.23 (1.22 stable)

## Преимущества:
-------------
- Простота и читаемость: Go имеет лаконичный синтаксис, что делает код более понятным и легким для чтения
- Высокая производительность: Go компилируется в машинный код, что обеспечивает высокую скорость выполнения программ
- Параллелизм: Встроенная поддержка горутин и каналов позволяет легко создавать конкурентные приложения
- Статическая типизация: Статическая типизация помогает избежать многих ошибок на этапе компиляции, что повышает надежность кода
- Стандартная библиотека: Go предлагает мощную стандартную библиотеку, которая включает в себя множество полезных пакетов для работы с сетью, файловой системой и другими задачами
- Кроссплатформенность: Go позволяет компилировать приложения для различных операционных систем и архитектур с минимальными усилиями
- Инструменты для разработки: Go поставляется с набором инструментов для форматирования кода, тестирования и управления зависимостями

## Недостатки:
-------------
- Отсутствие generics (до версии 1.18): Ранее Go не поддерживал обобщенные типы, что ограничивало гибкость кода. Однако эта проблема была решена в версии 1.18
- Меньше библиотек и фреймворков: По сравнению с языками, такими как Python или Java, экосистема Go может быть менее обширной
- Упрощенная обработка ошибок: В Go нет встроенного механизма исключений, что может привести к избыточному коду для обработки ошибок
- Отсутствие поддержки наследования: Go использует композицию вместо наследования, что может быть непривычно для разработчиков, привыкших к объектно-ориентированным языкам
- Сложности с интерфейсами: Хотя интерфейсы в Go мощные, их использование может быть не интуитивно понятным для новичков
- Долгое время компиляции: Для крупных проектов время компиляции может быть заметным, хотя это не всегда критично
    
# Память
------------------------------------
- escape analysis - позволяет узнать где выделяется переменная, в стеке или куче - техника оптимизации компилятора для повышения производительности, определяет возможность безопасного выделения переменной в стек
- стек горутин - 10мб
- pprof - позволяет обнаружить чересчур большое выделение памяти

## стек и куча (heap and stek)
------------------------------------
- стек и куча — это две области, в которых может быть выделена память. Стек обычно быстрее выделяется и удаляется, поскольку для этого нужно просто переместить указатель стека, но его размер также более ограничен
- cтек идеально подходит для локальных переменных и временных данных
- куча предоставляет гибкость для динамически выделяемых объектов и структур данных
  
## стек
------------------------------------
- Стек — это область памяти, которая используется для хранения локальных переменных, параметров функций и информации о вызовах функций. Он работает по принципу LIFO (Last In, First Out), что означает, что последняя добавленная запись будет первой, которая будет удалена

### Основные характеристики стека:
- Фиксированный размер: Размер стека для каждой горутины задается при создании и может быть ограничен. Если стек переполняется, это приводит к панике в программе
- Быстрый доступ: Память в стеке выделяется и освобождается быстро, так как операции происходят по принципу добавления и удаления элементов с вершины стека
- Автоматическое управление: Когда функция завершается, все локальные переменные и параметры автоматически освобождаются
- Безопасность типов: В стеке хранятся только значения, которые имеют фиксированный размер (например, примитивные типы и структуры)

### выделение памяти для стека
- Размер стека: По умолчанию размер стека в Go для новой горутины составляет 2 КБ (2048 байт). Этот размер может увеличиваться по мере необходимости, если стек переполняется, но есть верхний предел, который зависит от платформы.
- Типы данных: Стек предназначен для хранения локальных переменных и параметров функций. В зависимости от типа данных, размер переменной может варьироваться. Например, простые типы, такие как int, float64, и указатели занимают фиксированное количество байт (например, 8 байт на 64-битной системе).
- Структуры и массивы: Если вы пытаетесь разместить большие структуры или массивы в стеке, это может быстро привести к переполнению стека. В таких случаях рекомендуется использовать кучу для хранения больших объектов.
- Переполнение стека: Если размер размещаемого значения превышает доступный размер стека, это приведет к панике (panic) из-за переполнения стека.

- Пример использования стека:
```
package main

import "fmt"

func add(a int, b int) int {
    return a + b // Локальные переменные a и b хранятся в стеке
}

func main() {
    result := add(3, 4)
    fmt.Println("Результат:", result)
}
```
## Куча
------------------------------------
- Куча — это область памяти, используемая для динамического выделения памяти. Она позволяет выделять память для объектов, которые могут иметь неопределенный размер или срок жизни, например, для объектов, создаваемых с помощью new или make

### Основные характеристики кучи:
- Динамическое выделение: Память в куче выделяется во время выполнения программы и может иметь переменный размер
- Медленный доступ: Доступ к памяти в куче медленнее по сравнению со стеком, так как требуется дополнительная обработка для управления памятью
- Управление сборщиком мусора: Go использует сборщик мусора для автоматического управления памятью в куче. Это означает, что память, которая больше не используется, будет автоматически освобождена
- Гибкость: Куча позволяет создавать объекты с произвольным временем жизни, что удобно для работы с большими структурами данных и объектами, которые должны существовать дольше, чем текущая функция

- Пример использования кучи:
```
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    // Выделение памяти в куче для структуры Person
    p := &Person{Name: "Alice", Age: 30}
    fmt.Println("Имя:", p.Name, ", Возраст:", p.Age)
}
```

### Гонка данных/race condition
- ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации.
- обнаружить race condition позволяют инструменты golang - benchmark с флагом race - показывает гонку на этапе компиляции

### утечка памяти
- перерасход оперативной памяти

### переполнение и спираль смерти
- рекурсивная функция, которая вызывается много раз

### Как реализовать Enum в Golang?
iota
const (
       Red = iota // 0
       Green // 1
       Blue    // 2
)

# Ошибки/Паника
==============================
- ошибки используются для всего где не нужна паника, паника - для экстренного выброса ошибки на самый верх стектрейса
- для обработки паники используется recover
- ***паника*** - критическая ошибка делающая невозможным дальнейшее выполнение программы (при этом есть некоторые ошибки которые даже через паник отловить невозможно)

###  парадигма в Golang с точки зрения обработки исключений и ошибок
- во всех местах где ошибка возможна - получать объект результата и объект ошибки, затем сравнивать с nil
НЕ ИСПОЛЬЗОВАТЬ панику вместо ошибок

###  функции для оборачивания и сравнения ошибок
- Сравнение типов (type assertion)
```
if errors.As(err, &target) {
    fmt.Println(target) // no model found for id
}
```

# Указатели
==============================

## Средне
-------------
### Что такое указатель?
объект хранящий адрес ячейки памяти. За счёт того что мы знаем что это указатель - мы можем через него перейти к самому объекту средствами golang (разыменование)


### средства обобщённого программирования
- дженерики позволяют статически обозначить в коде места в которых возможно обобщённое программирование. Можно сказать что дженерики - это встроенная в golang кодогенерация
- дженерики появились в версии 1.18
- кодогенерация позволяет создавать новые классы и методы через компиляцию. 


# Конструкции
==============================

## Редко
-------------
### Гарантирует ли порядок выполнения конструкция select-case?
нет не гарантируется 
```golang
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
```

### Как выглядит конструкция утверждения типа switch?
```golang    
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
```

### Нужно ли в switch-case проставлять break?
нет, свитч отработает только один раз


### Чем отличается switch от select?
свитч работает с данными, а селект с каналами
свитч гарантирует порядок сравнений, селект работает случайно

### Что такое switch type?
// Golang program to illustrate the
// concept of type switches
var value interface{} = "GeeksforGeeks"
  
  // type switch to find 
  // out interface{} type
  switch t := value.(type){
  
    case int64:

      // if type is an integer
      fmt.Println("Type is an integer:", t)

    case string:

      // if type is a string
      fmt.Println("Type is a string:", t)

    case nil:

      // if type is nil (zero-value)
      fmt.Println("Type is nil.")
    default:

      // if type is other than above
      fmt.Println("Type is unknown!")
  }


# ООП
==============================

## Средне
-------------
### Как устроено ООП в Golang?
### Как реализуется наследование в Golang?
```golang
type StructA struct{
 Name string
}

type StructB struct{
 Name string
}
```
сравнить две реализации:
```golang
type StructC struct{
 A StructA
 B StructB
}

// ambiguous definition
// скорее всего golang не даст так сделать
type StructC struct{
 StructA
 StructB
}
```

# Основные функции
--------------------------
- параметры в функцию передаются ВСЕГДА по значению, происходит копирование (либо указателей либо значений)

## defer
--------------------------
- используется для отложенного вызова кода по окончании выполнения функции, например defer wg.Done() для ожидания работы всех горутин
- порядок выполнения нескольких defer - обратный
- код в defer вычисляется в моменте (с копией всех входящих параметров) и выполняется после return
- применяется в recover для отлова паники (помещаектся в начало)
- **Паника возникает до вызова defer**

### defer не вызывается
- При обработке ошибок, или в любом другом случае, когда мы вызывается os.Exit()
- при log.Fatal(), т.к. внутри неё также прячется os.Exit()

## recover()
--------------------------
- функция для отлова паники
Внутри отложенной функции(defer) вызывается recover(), чтобы попытаться восстановить выполнение программы. Если паника произошла, recover() вернет значение, вызвавшее панику.
- пример
```
func safeFunction() {
	// Отложенная функция для восстановления
	defer func() {
		if r := recover(); r != nil {
			// Обработка паники
			fmt.Println("Паника поймана:", r)
		}
	}()

	// Код, который может вызвать панику
	fmt.Println("Выполняем безопасную функцию...")
	causePanic() // Вызов функции, которая вызывает панику
	fmt.Println("Эта строка не будет выполнена") // Эта строка не выполнится
}

// Функция, вызывающая панику
func causePanic() {
	panic("Что-то пошло не так!")
}

func main() {
	safeFunction()
	fmt.Println("Программа продолжает выполнение после отлова паники.")
}
```

# Основные пакеты
----------------------------
## errors
----------------------------
## context
----------------------------
- Пакет context в Go предоставляет механизм для передачи значений, отмены и дедлайнов (временных ограничений) между горутинами. Он особенно полезен для управления длительными операциями, такими как сетевые запросы, операции ввода-вывода и другие задачи, которые могут занять неопределенное время.
- Пакет context является мощным инструментом для управления горутинами и асинхронными операциями в Go. Он позволяет более эффективно управлять временем выполнения, отменой операций и передачей данных между горутинами, что делает его важным для разработки надежных приложений.
  
### Основные функции пакета context:
- Передача данных: Вы можете передавать значения между различными функциями и горутинами.
- Отмена: Вы можете отменить выполнение операций, если они больше не нужны.
- Дедлайны: Вы можете установить временные ограничения на выполнение операций.
- 
### Применение:
- В веб-серверах для отмены запросов, если клиент отключается.
- В фоновых задачах, чтобы избежать выполнения долгих операций, если они больше не нужны.
- Для управления зависимостями между горутинами.
  
### Примеры использования пакета context
- Пример 1: Использование контекста для отмены операции
```
// контекст с отменой
ctx, cancel := context.WithCancel(context.Background()) // создание контекст с отменой
defer cancel() // Убедимся, что cancel вызывается в конце

go func() {
// Имитация длительной операции
	time.Sleep(2 * time.Second)
	fmt.Println("Длительная операция завершена")
	cancel() // Отмена контекста
}()

// Ожидание завершения операции
select {
	case <-ctx.Done(): fmt.Println("Операция была отменена:", ctx.Err())
	case <-time.After(3 * time.Second): fmt.Println("Операция завершена без отмены")
}
```

- Пример 2: Использование контекста с дедлайном
``` 
// контекст с дедлайном
ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))
defer cancel() // Убедимся, что cancel вызывается в конце

go func() {
	// Имитация длительной операции
	time.Sleep(2 * time.Second)
	fmt.Println("Длительная операция завершена")
}()

// Ожидание завершения операции
select {
	case <-ctx.Done(): fmt.Println("Операция завершилась с ошибкой:", ctx.Err())
	case <-time.After(3 * time.Second): fmt.Println("Операция завершена без отмены")
}
```

## reflect
----------------------------
- Пакет reflect в Go предоставляет возможность работы с типами данных во время выполнения программы. Он позволяет динамически анализировать и изменять значения объектов, что делает его мощным инструментом для создания универсальных функций, работы с сериализацией, ORM (Object-Relational Mapping) и другими сценариями, где требуется работа с типами и значениями в динамическом режиме
- Пакет reflect в Go предоставляет мощные инструменты для работы с типами и значениями во время выполнения. Он позволяет динамически исследовать структуру типов, изменять значения и вызывать методы. Однако следует использовать его с осторожностью, так как работа с рефлексией может быть менее эффективной и более сложной, чем работа с статически типизированными данными.

### Основные возможности пакета reflect
- Получение информации о типах: Пакет reflect позволяет получать информацию о типах данных, таких как имя типа, размер, методы и поля
- Динамическое создание и изменение значений: можно создавать новые значения и изменять существующие значения, используя интерфейсы Value и Type
- Работа с полями и методами: Пакет позволяет получать доступ к полям и методам структур и интерфейсов

### Основные структуры и функции
- Type: Интерфейс, который представляет тип данных
- Value: Интерфейс, который представляет значение данных и предоставляет методы для работы с ним
- TypeOf(): Функция, которая возвращает тип значения
- ValueOf(): Функция, которая возвращает значение, обернутое в reflect.Value
  
### Примеры использования
- Получение информации о типе
```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 42
    t := reflect.TypeOf(x)
    fmt.Println("Тип:", t)               // Тип: int
    fmt.Println("Имя:", t.Name())        // Имя: int
    fmt.Println("Размер:", t.Size())      // Размер: 8 (для 64-битной архитектуры)
}
```
- Получение информации о значении
```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(x)

    fmt.Println("Значение:", v)          // Значение: 3.14
    fmt.Println("Тип:", v.Type())        // Тип: float64
    fmt.Println("Сравнение:", v.Float() == 3.14) // Сравнение: true
}
```
- Изменение значений
Чтобы изменить значение переменной, нужно передать указатель

```package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 10
    v := reflect.ValueOf(&x).Elem() // Получаем значение по указателю

    v.SetInt(20) // Изменяем значение
    fmt.Println("Новое значение:", x) // Новое значение: 20
}
```
- Работа с полями структуры
```
package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Alice", Age: 30}
    v := reflect.ValueOf(p)

    // Получение полей структуры
    for i := 0; i < v.NumField(); i++ {
        field := v.Field(i)
        fmt.Printf("Поле %d: %v\n", i, field.Interface())
    }
}
```
- Вызов методов
```
package main

import (
    "fmt"
    "reflect"
)

type Greeter struct{}

func (g Greeter) Greet(name string) {
    fmt.Println("Hello,", name)
}

func main() {
    g := Greeter{}
    v := reflect.ValueOf(g)

    // Вызов метода
    method := v.MethodByName("Greet")
    args := []reflect.Value{reflect.ValueOf("World")}
    method.Call(args) // Вывод: Hello, World
}
```
## runtime
----------------------------
- основные компоненты - планировщик, сборщик мусора, переменные среды (GOMAXPROC - позволяет узнать количество ядер или виртуальных потоков)
- Пакет runtime в Go предоставляет функции для взаимодействия с средой выполнения (runtime) программы. Он позволяет получать информацию о текущем состоянии программы, управлять горутинами, а также работать с памятью и системными ресурсами. Пакет runtime является важным инструментом для разработки, отладки и оптимизации приложений на Go
- Пакет runtime в Go предоставляет мощные инструменты для управления средой выполнения, горутинами и памятью. Он полезен для мониторинга состояния приложения, диагностики проблем и оптимизации производительности. Используя функции из этого пакета, разработчики могут более эффективно управлять ресурсами и понимать, как их программы взаимодействуют с системой

### Основные возможности пакета runtime
- Управление горутинами: Пакет предоставляет функции для работы с горутинами, такими как получение информации о количестве активных горутин и управление планировщиком
- Информация о стеке: Вы можете получить информацию о текущем стеке вызовов, что полезно для отладки и диагностики
- Работа с памятью: Пакет позволяет получать информацию о использовании памяти и управлять сборщиком мусора
- Параметры среды выполнения: Вы можете получать информацию о текущей среде выполнения, включая версию Go и архитектуру

### Основные функции и структуры
- GoID(): Возвращает идентификатор текущей горутины
- NumGoroutine(): Возвращает количество активных горутин
- Stack(): Получает информацию о стеке вызовов текущей горутины
- GC(): Запускает сборщик мусора
- Version(): Возвращает версию Go, используемую в текущем приложении
  
### Примеры использования
- Получение идентификатора горутины
```
package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Println("Идентификатор горутины:", runtime.NumGoroutine())
}
```
- Получение информации о стеке
```
package main

import (
    "fmt"
    "runtime"
)

func printStack() {
    buf := make([]byte, 1<<16) // 64KB
    stackSize := runtime.Stack(buf, true)
    fmt.Printf("Стек вызовов:\n%s\n", buf[:stackSize])
}

func main() {
    printStack()
}
```
- Управление сборщиком мусора
```
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // Запуск сборщика мусора
    runtime.GC()
    fmt.Println("Сборщик мусора запущен")
}
```
- Получение информации о текущем окружении выполнения
```
package main

import (
    "fmt"
    "runtime"
)

func main() {
    fmt.Println("Версия Go:", runtime.Version())
    fmt.Println("Архитектура:", runtime.GOARCH)
    fmt.Println("Операционная система:", runtime.GOOS)
}
```

## Планировщик
- Go использует планировщик, который управляет выполнением горутин. Он распределяет горутины по доступным потокам (операционным системам) и пытается эффективно использовать ресурсы процессора. Планировщик Go работает с концепцией "многопоточности", где несколько горутин могут выполняться параллельно на нескольких ядрах процессора.
- тип планировщика - кооперативный, но сейчас идёт переход на конкурирующий
- GMP модель
- локальные и глобальные очереди
- кража горутин и перераспределение нагрузки
- разница между вытесняющим и кооперативным планировщиком: в кооперативной системе задача будет продолжаться до тех пор, пока она явно не откажется от управления ЦП. В вытесняющей (упреждающей) модели задачи могут быть принудительно приостановлены

### вытесняющая многозадачность
- Вытесняющая многозадачность (preemptive multitasking) — это вид многозадачности, при котором планировщик задач принудительно приостанавливает выполнение текущей задачи и отдает управление другой задаче, готовой для исполнения. Приостановка текущей задачи называется вытеснением.

### кража горутин (stealing goroutines) и перераспределение нагрузки
- когда одна горутина (или поток) может взять на себя работу, которая была запланирована для другой горутины
- Предположим, у вас есть несколько горутин, которые обрабатывают задачи из общей очереди. Если одна горутина завершает свою задачу и обнаруживает, что в очереди есть другие задачи, она может "забрать" следующую задачу для обработки. Это позволяет эффективно использовать ресурсы и уменьшить время простоя
- планировщик может перемещать горутины между потоками для оптимизации работы:

1. **Работа с очередями**: Когда одна горутина завершает свою работу, планировщик может взять другую горутину из очереди и запустить её на том же потоке. Это позволяет более эффективно использовать процессорное время.
2. **Работа с блокировками**: Если одна горутина блокируется (например, ожидает данные из канала), планировщик может "украсть" другую горутину из очереди и выполнить её, чтобы не простаивать.


## сборщик мусора/GC
----------------------------
- Сборщик мусора в Go значительно упрощает управление памятью, позволяя разработчикам сосредоточиться на разработке функциональности приложения. Он эффективен и оптимизирован для работы с параллельными горутинами, что делает его важной частью экосистемы Go
```
debug.SetGCPercent(-1) // best practice - установить 80%
debug.SetMemoryLimit(math.MaxInt64)
```
- GC запускается по достижении порога по памяти. В момент запуска останавливается вся программа. Работает по механизму mark-and-sweep
- При необходимости выделения дополнительной памяти, при том, что какая-то память уже вышла из употребления, GC производит перераспределение
- GC служит для автоматического анализа используемой и неиспользуемой памяти
- можно оптимизировать работу GC если размещать данные на стеке

Сборщик мусора (Garbage Collector, GC) в Go — это автоматизированный механизм управления памятью, который отвечает за освобождение неиспользуемой памяти, выделенной под объекты, которые больше не нужны программе. Это помогает избежать утечек памяти и упрощает разработку, так как разработчикам не нужно вручную управлять памятью.

### Основные характеристики сборщика мусора в Go:

1. **Автоматическое управление памятью**: Go использует сборщик мусора для автоматического освобождения памяти, что позволяет разработчикам сосредоточиться на логике приложения, а не на управлении памятью
2. **Сборка мусора на основе трассировки**: Go использует алгоритм сборки мусора, основанный на трассировке, который определяет, какие объекты в памяти все еще используются (достижимы) и какие могут быть удалены (недостижимы)
3. **Генерационная сборка мусора**: Хотя в Go нет строгой генерационной сборки мусора, он использует концепцию "молодых" и "старых" объектов. Молодые объекты, которые были недавно созданы, собираются чаще, чем старые объекты, которые существуют дольше. Это помогает оптимизировать производительность, так как большинство объектов в программах имеют короткий срок жизни
4. **Параллельный сборщик мусора**: Сборщик мусора в Go работает параллельно с основным потоком выполнения программы. Это означает, что сборка мусора может происходить, не блокируя выполнение горутин, что уменьшает задержки
5. **Режим "stop-the-world"**: Хотя сборщик мусора работает параллельно, в определенные моменты он может приостанавливать выполнение всех горутин (режим "stop-the-world") для выполнения определенных операций, таких как обновление ссылок на объекты. Однако старается минимизировать время, проведенное в этом режиме
6. **Настройки и параметры**: В Go есть возможность настраивать параметры сборщика мусора, такие как частота сборки мусора и пороговые значения для запуска сборки. Это может помочь оптимизировать производительность приложения в зависимости от его требований

### Пример

- Вот простой пример, который показывает, как Go управляет памятью с использованием сборщика мусора:

```
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // Запускаем сборщик мусора
    runtime.GC()

    // Создаем массив, который будет собран сборщиком мусора
    arr := make([]int, 1000000)
    for i := 0; i < len(arr); i++ {
        arr[i] = i
    }

    // Удаляем ссылку на массив, чтобы он стал недостижимым
    arr = nil

    // Запускаем сборщик мусора снова
    runtime.GC()

    fmt.Println("Сборка мусора завершена")
}
```

## переменные среды
------------------------------
- Переменные окружения в Go предоставляют удобный способ настройки приложений и управления конфигурацией. Они позволяют разработчикам легко изменять поведение приложений без изменения кода, что делает их особенно полезными в различных средах развертывания
- В Go переменные окружения (или переменные среды) используются для настройки поведения приложений и передачи конфигурационных данных. Они представляют собой пары "ключ-значение", которые могут быть установлены в операционной системе и доступны программам во время выполнения. В Go работа с переменными окружения осуществляется через пакет `os`.

### Основные функции работы с переменными окружения в Go

1. **Получение значения переменной окружения**:
   Для получения значения переменной окружения используется функция `os.Getenv`. Если переменная не установлена, функция вернет пустую строку.

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       value := os.Getenv("MY_ENV_VAR")
       fmt.Println("MY_ENV_VAR:", value)
   }
   ```

2. **Установка переменной окружения**:
   Для установки переменной окружения в текущем процессе используется функция `os.Setenv`. Однако изменения будут действовать только в пределах текущего процесса и его дочерних процессов.

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       os.Setenv("MY_ENV_VAR", "Hello, World!")
       value := os.Getenv("MY_ENV_VAR")
       fmt.Println("MY_ENV_VAR:", value)
   }
   ```

3. **Удаление переменной окружения**:
   Чтобы удалить переменную окружения, можно использовать функцию `os.Unsetenv`.

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       os.Setenv("MY_ENV_VAR", "Hello, World!")
       fmt.Println("MY_ENV_VAR:", os.Getenv("MY_ENV_VAR"))

       os.Unsetenv("MY_ENV_VAR")
       fmt.Println("MY_ENV_VAR:", os.Getenv("MY_ENV_VAR")) // Выведет пустую строку
   }
   ```

4. **Получение всех переменных окружения**:
   Для получения всех переменных окружения можно использовать функцию `os.Environ`, которая возвращает срез строк в формате "KEY=VALUE".

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       for _, env := range os.Environ() {
           fmt.Println(env)
       }
   }
   ```
### GOMAXPROC
- `GOMAXPROCS` — это переменная среды в Go, которая определяет максимальное количество операционных системных потоков (потоков выполнения), которые могут одновременно выполняться в программе. Она управляет количеством потоков, которые могут использоваться для выполнения горутин, что может повлиять на производительность многопоточных приложений
- По умолчанию `GOMAXPROCS` устанавливается в значение, равное количеству логических процессоров в системе, доступных для выполнения программы. Однако вы можете изменить его в коде с помощью функции `runtime.GOMAXPROCS`
- Использование `GOMAXPROCS` позволяет управлять параллелизмом в Go-программах. Установка этого значения может помочь оптимизировать производительность, особенно в приложениях, которые интенсивно используют вычисления. Однако для большинства случаев значение по умолчанию (количество логических процессоров) будет оптимальным.

- Пример использования `GOMAXPROCS`

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func main() {
    // Получаем текущее значение GOMAXPROCS
    currentMaxProcs := runtime.GOMAXPROCS(0)
    fmt.Println("Текущее значение GOMAXPROCS:", currentMaxProcs)

    // Устанавливаем GOMAXPROCS в 2
    runtime.GOMAXPROCS(2)
    fmt.Println("Новое значение GOMAXPROCS:", runtime.GOMAXPROCS(0))

    var wg sync.WaitGroup

    // Запускаем несколько горутин
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Printf("Горутина %d запущена\n", i)
            time.Sleep(2 * time.Second) // Симуляция работы
            fmt.Printf("Горутина %d завершена\n", i)
        }(i)
    }

    // Ожидаем завершения всех горутин
    wg.Wait()
    fmt.Println("Все горутины завершены")
}
```

### Примеры использования переменных окружения

- **Конфигурация приложений**: Переменные окружения часто используются для хранения конфигурационных данных, таких как параметры подключения к базе данных, ключи API и другие настройки, которые могут отличаться в зависимости от окружения (например, разработка, тестирование, продакшен).
- **Секреты**: Переменные окружения могут использоваться для хранения конфиденциальной информации, такой как пароли и токены, чтобы не хранить их в исходном коде.


# Другие вопросы 
8. Что делает функци init()? - выделяет фрагмент кода, который должен выполняться перед всеми другими частями пакета.
   
# БД
-------------
 ## виды индексов
 1. B-Tree - бинарное дерево
 2. HASH - под капотом хэш-функция
 3. GiST - для работы с сложными типами данных: геометрические объекты, текст и массивы. Они позволяют быстро выполнять поиск по пространственным, текстовым и иерархическим данным.
 4. GIN - для полнотекстового поиска и поиска по массивам
 5. BRIN - для компактного представления больших объемов данных
 6. Составные индексы - создаются на основе нескольких колонок (больше 2х)
 
## join
- В SQL операции объединения (JOIN) позволяют комбинировать строки из двух или более таблиц на основе связанных полей между ними. INNER JOIN, LEFT JOIN и RIGHT JOIN
- Выбор типа JOIN зависит от того, какие данные нужны и как их отобразить
- INNER JOIN используется для получения только совпадающих данных
- LEFT JOIN и RIGHT JOIN — для получения всех данных из одной таблицы с возможностью добавления данных из другой таблицы, даже если совпадений нет

### INNER JOIN
- INNER JOIN возвращает только те строки, которые имеют совпадения в обеих таблицах
- Пример использования:
```
SELECT * FROM TableA
INNER JOIN TableB ON TableA.id = TableB.a_id;
```
- Ключевые особенности:
1. Возвращает только те записи, которые соответствуют критериям соединения
2. Если в одной из таблиц нет соответствующей записи, эта запись не будет включена в результат
3. Используется, когда необходимо получить данные, которые существуют в обеих таблицах
   
### LEFT JOIN (LEFT OUTER JOIN)
- LEFT JOIN возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если соответствующих строк в правой таблице нет, возвращаются NULL-значения для колонок из правой таблицы.
- Пример использования:
```
SELECT *
FROM TableA
LEFT JOIN TableB ON TableA.id = TableB.a_id;
```
- Ключевые особенности:
1. Все записи из левой таблицы будут включены в результат, даже если нет совпадений в правой таблице.
2. Если нет соответствующих записей в правой таблице, значения для этих колонок будут NULL.
3. Используется, когда нужно получить все данные из одной таблицы и при этом дополнительные данные из другой таблицы, если они есть.
   
### RIGHT JOIN (RIGHT OUTER JOIN)
- RIGHT JOIN возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если соответствующих строк в левой таблице нет, возвращаются NULL-значения для колонок из левой таблицы.
- Пример использования:
```
SELECT *
FROM TableA
RIGHT JOIN TableB ON TableA.id = TableB.a_id;
```
- Ключевые особенности:
1. Все записи из правой таблицы будут включены в результат, даже если нет совпадений в левой таблице.
2. Если нет соответствующих записей в левой таблице, значения для этих колонок будут NULL.
3. Используется, когда нужно получить все данные из правой таблицы и дополнительные данные из левой таблицы, если они есть.

