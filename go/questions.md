# Мапа
==============================
## Часто
-------------
### Что такое мапа?
- Мапа это хэштаблица, она хранит пары "ключ-значение", где каждому уникальному ключу соответствует определенное значение
Ключи в мапе должны быть сравнимыми типами, например string, int, bool...
- Бакет(Bucket/Slot) - cтруктура данных, в которой хранятся ключи, значения и топхеш . Данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов
- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу

## Средне
-------------
### Что произойдет при конкррентной записи в мапу? 
- Мапа не потокобезопасна и будет состояние гонки (поведение программы не детерминировано)
- При работе с мапой в конкурентном режиме, в частности, при записи, возникнет состояние гонки. Это состояние, когда несколько потоков пытаются получить и обновить одни и те же данные. Чтобы предотвратить состояние гонки, нужно заблокировать общие данные так, чтобы только одна горутина имела возможность обновлять данные в данный момент времени, а при чтении горутинами ни одна не могла ничего записать в мапу в текущий момент.
- Для решения проблемы состояния гонки используется объект RWMutex, который при записи блокирует код для остальных горутин на время выполнения операций, затем в конце функции (с помощью defer) разблокирует. При чтении он блокирует только то место, где происходит запись.

### Какие ключи могут быть у мапы?
- Любые сравнимые типы данных

### Можно ли взять адрес элемента мапы и почему?
- Нет нельзя, поскольку это нарушит целостность данных - мапа не потокобезопасна (возможны ошибки - значение переместиться в другой участок памяти (бакет) или память вообще будет высвобождена и будет out of bounds)

### Как работает эвакуация данных?
- Она начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.
- Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
Именно поэтому в структуре мапы есть свойство B — это степерь двойки, которая показывает кол-во бакетов.
- Во время эвакуации данных, все операции мапы остаются доступны. Поэтому во многих частях исходного кода есть обращения как к buckets, так и к oldbuckets. После завершения копирования данных, oldbuckets становится равно nil.
- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.

### Другие особенности map
- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;
- При коллизиях используется стратегия сlosed addressing. Мы перебираем все ячейки бакета (их 8) и ищем первое свободное место;
- При росте элементы переносятся в новые бакеты постепенно, а не все сразу

## Редко
-------------
### Как разрешаются коллизии в мапе?
- В рамках коллизии выбирается один и тот же бакет и если происходит коллизия - создаётся новый бакет который прилинковывается к первоначальному (аналог связного списка).

### Как сделать конкурентную запись в мапу?
- Обернуть мапу в структуру в которую доложить мьютекс (классический или RWMutex)

### Как устроена мапа под капотом?
= Тип map в Go представляет собой ассоциативный массив или словарь, который состоит из набора пар ключ-значение. Ключи и значения могут быть любого типа, но все ключи должны быть одного типа, и все значения должны быть одного типа.
- Хеш таблица + бакеты (в рамках бакета 8 позиций на которые мы можем записывать значение)
- Внутри себя, map реализован как хэш-таблица, что обеспечивает эффективный доступ к значениям по ключу. Хэш-таблица является структурой данных, которая использует хэш-функцию для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.
- Порядок элементов в map не гарантирован и может меняться при каждой итерации по map

### Как достигается константная сложность работы с мапой?
- За счёт хеш-таблицы

### Для чего используется мапа?
- Для хранения данных по ключу

### Мапа потокобезопасная?
- Нет (но есть sync.Map)

### Пробовали из разных потоков писать в мапу?
- Да, пробовал, происходит состояние гонки 

### Стало слишком много коллизий в мапе, как решить проблему?
- Переопределить хеш функцию у своих сравнимых структур ключа

### Какая сложность работы с мапой?
- В лучшем случае - О(1), в худшем - О(n) (завист от количества коллизий/хеш функции)

### Чем мапа отличается от sync.Map?
- sync.Map - потокобезопасная мапа, содержащая под капотом Мьютекс

# Массивы/Слайсы
==============================
## Часто
-------------
### Что такое слайс?
- Это динамическая структура данных (может изменять свою длинну), надмножество массивов. Слайс создает массив, и при надобности расширяет его.
- Структура хранящая внутри указатель на массив определённой длинны и число-каписити
Слайс содержит ссылку на начало области данных: длину (количество элементов заданного типа) и емкость (capacity)

### Чем массив отличается от слайса?
- Массив имеет фиксированный размер и имеет фиксированное количество элементов. 
- массив является динамической структурой данных, является ссылочным типом

## Средне
-------------
### Как работает append?
- В зависимости от текущих len/cap либо дописывает значение в текущий массив (возможна перезапись), либо создаёт новый массив х2 размера + подменяет указатель в слайсе + дописывает значение в новый массив

## Редко
-------------
### Как правильно/неправильно работать со слайсом?
- Всегда передавать указатель на слайс - правильно (потому что может произойти пересоздание внутреннего массива и потеря указателя)

### Для чего можно использовать массивы в Golang?
- Для хранения значений при условии что мы ГАРАНТИРОВАНО знаем что количество не будет меняться

### До какого размера можно увеличивать слайс?
- В зависимости от версии golang значение меняется. В настоящий момент я не помню и босюь обмануть - лучше сходить в документацию

### Допустима ли конкуррентная работа со слайсом?
- Нет, слайс не потокобезопасен

### Для чего используются слайсы?
- Для храния динамически меняющих свой размер массивовов данных

### Берем от слайса слайс, куда будет указывать его указатель?
- На сегмент исходного массива

### В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?
- Придётся проводить дополнительные разименования, изменится сигнатура функции (**[]int *[]int)

### Где в памяти размещается массив, а где слайс?
- При компиляции программы будет происходить escape анализ. Скорее всего указатель на внутренний массив слайса будет на стеке, а сам массив - в heap. 
- Если массив будет превышать некий размер то он тоже поедет на кучу.

### Какие методы оптимизации работы со слайсами ты бы применил в работе?
- Можно копировать их между горутинами таким образом уменьшив количесто аллокация.

### Какие есть ограничения при работе со слайсом?
- Нет удаления полноценного - по факту мы пересоздаём слайс меньшей длинны. А высвобождение данных лежит на исполнения.

### Какие есть средства для добавления элементов в слайс?
- append

### Какая есть функции для создания слайса с длиной отличной от нуля?
- make

### С какой скоростью идет поиск в массиве и почему?
- O(n) - идёт полный перебор

### Чем хорош массив по сравнению со слайсом?
- Конечная длинна и передача по значению

### Что такое массив?
- Последовательный сегмент в памяти в каждой из ячеек которого (размер ячейки зависит от типа данных) хранятся значения. По факту массив - это указатель на начало последовательного сегмента, а обращение к каждой из его ячеек - это приплюсовывание к начальному указателю номера ячейки*размер.

# Каналы
==============================
![image](https://github.com/user-attachments/assets/81b1ed70-72e4-4eea-82ce-46cd306a336a)

## Часто
-------------
### Что такое каналы?
- Канал - структура в го созданная для передачи данных между горутинами. Под капотом устроена достаточно сложно, в базовую комплектацию входит - ёмкость, список читателей, список писателей, буфер для обмена данными (1 в случае небуф, n в случае буферизованного).

## Средне
-------------
### Как устроен канал и как он работает под капотом?
- Есть сегмент памяти для переваемых значений (1 или множества). Есть список читающих и пишущих горутин. Есть размер канала.

### Какие есть типы каналов в Golang?
- Буферизованые и небуферизованые. Однонаправленые и двунаправленые
- буферизованные - для пересылки массивов данных
- небуферизованные - для пересылки событий

### Что если писать/читать в закрытый канал?
- При попытке записи в закрытый канал будет паника. При записи в заполненные канал будет блокировка. При чтении из закрытого канала будут считываться записанные значения, а когда они закончатся - дефолтные значения в зависимости от объявленного типа канала (в случае int-0, string-""). Также можно считать факт наличия значений в канале. 

## Редко
-------------
### Чем отличается запись/чтение в буферизованном и небуферизованном канале?
- При записи в небуферизованый канал если уже значение - deadlock
- При записи в буферизованый канал если закончилось место - deadlock
- При чтении из небуферизованого канала - будет происходить копирование значения между стеками горутин.
- При чтении из буферизованого канала - будет происходить чтение из кучи, где размещён обменный массив канала.

### Что произойдет с читателями/писателями если закрыть канал?
- Читатели смогут понять что канал закрыт через функции range/select. Писатели получат дедлоки если нет механизма их уведомления. ОЧЕНЬ ВАЖНО закрывать канал там где пишешь.

### Что используется для неблокирующего чтения из канала?
- select/range

### Какие операции есть с каналами?
- запись, чтение, закрытие (close), создание (make)

### Какие параметры могут иметь каналы?
- Тип и размер внутреннего массива (буф/небуф)

### Для чего используется select при работе с каналами?
- Для неблокирующего чтения

### Как проверить, что канал закрыт?
- Читать его через функцию range/select или считывать два значения.

### Как сделать канал буферизованным?
- make(chan int, 3)

### Есть две горутины, одна пишет в небуферизованный, а другая в буферизованный канал, оба не читаются. Что произойдет?
- Та что пишет в НЕбуферизованый будет блокироваться пока из канала не будет вычитано значение.

# Примитивы синхронизации
==============================
## Часто
-------------
### Какие примитивы синхронизации есть в Golang?
- Atomic, Mutex, RWMutex, WaitGroup, lock, sync.Map, Pool, Semaphore

## Средне
-------------
### Чем мьютекс отличается от семафора?
- Мьютекс позволяет организовать доступ к коду одновременно только одной горутине на запись, семафор - нескольким.

## Редко
-------------
### Чем мьютексы отличаются от атомиков?

### Что из пакета sync используешь на практике?
- Atomic, Mutex, RWMutex, lock, sync.Map

### Что можно использовать для ожидания выполнения N горутин?
- WaitGroup, Atomic

### Какие примитивы синхронизации использовал в работе и для чего?
- atomic - инкрементирование счётчкиов (например метрики)
- mutex - контроль доступа к коду
- RWMutex - контроль доступа к данным
- WaitGroup - Ожидание выполние параллельных задач (например обращение к 3 репозиториям)

### Как устроена WaitGroup под капотом и как ее можно реализовать самому?
- Под капотом там счётчик который уменьшается/увеличивается через Add/Done

### Сколько нужно ядер, чтобы начать использовать sync.Map?
- sync.Map начинает выигрывать в производительности от 4 ядер

### Расскажи про sync.Map
- потокобезопасная мапа. Под капотом это мапа к которой прикрутили RWMutex

### Расскажи про пакет sync
- В нём хранятся потокобезопасные структуры данных и примитивы сихнронизации потоков

### Когда нужно использовать Mutex, а когда RWMutex?
- Когда мы можем разделить наши операции на читающие/записывающие

### Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?
- Через атомик/семафор

### Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?
- Не факт, нужно использовать atomic/rwmutex

### Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?
- deadlock/race condition

### В чем разница между Mutex и RWMutex?
- В разделении операций на читающие/записывающие. На читающие не будет проихсодить блокировки при RWMutex

# Горутины
==============================
## Часто
-------------
### Что такое горутина?
- Это абстракция над потоками и процессорами в рамках которой мы исполняем наш код.
- Горутина может находиться в трех (основных) состояниях:
- Waiting: В этом состоянии, горутина бездействует. Например встает на паузу для операции с каналами или блокировками, либо может быть остановлена системным вызовом.
- Runnable: Горутина готова к тому чтобы быть исполненной, но еще не исполняется. Она ожидает своей очереди на потоке (M).
- Running: Горутина исполняется на потоке (M). Это будет продолжаться, пока работа не будет выполнена, или до тех пор, пока ее не прервет планировщик, либо что‑то еще ее не заблокирует.
- Горутины НЕ используются единожды и потом выбрасываются.
- Когда новая горутина инициируется, планировщик Go обращается к пулу горутин чтобы забрать одну, и если ни одной нет, то создает новую. Эта новая горутина добавляется в исполняемую очередь процесора (P).

### Чем горутина отличается от треда?
- Тред занимает больше памяти, горутина более легковесна. Тред управляется ядром системы, горутина - планировщиком GoLang

## Средне
-------------
### В чем преимущества горутин над тредами?
- Тред занимает больше памяти, горутина более лековесна. Тред управляется ядром системы, горутина - планировщиком GoLang

### Что есть в Golang для многопоточности?
- GMP модель, планировщик, каналы, пакет sync

## Редко
-------------
### Зачем понадобилось добавлять горутины в Golang?
Для поддержания большого кол-ва соеденений на сервере и более легковесного переключения контекста

### Как можно остановить горутину?
Она остановиться через 10мс после начала выполнения. Также можно передать в горутину объект контекста и задать TimeOut либо вызвать на этом объекте Cancel (ещё можно панику кинуть)

### Расскажите про конкуррентность и параллельность в Golang
GMP(PGM) модель
- P (processor) - логический процессор (не железо). Это условный контекст, который объединяет поток операционной системы (M) и очередь горутин. Количество горутин, привязанных к P неограниченно. По умолчанию количество P берётся из значения переменной среды GOMAXPROCS и равно количеству логических ядер компьютера.
- M (machine thread) - поток OS. Он закреплён за P и имеет с ним отношение один к одному.
- G (goroutine) - горутина
- В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (Global Run Queue - GRQ) и локальная очередь выполнения (Local Run Queue - LRQ). Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.
GRQ предназначен для горутин, которые еще не были назначены для какого-либо P.

### Когда возникает утечка горутины?
- Когда мы не закрываем внешнее взаимодействие (например файловый дескриптор)

### Какие есть способы связи между горутинами, какие плюсы и минусы?
- Каналы, внешние системы (шины данных например или тот же loopback порт)

# Интерфейсы
==============================
## Часто
-------------
### Что такое интерфейс?
Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. 

## Средне
-------------
### Как устроен интерфейс?
Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. 

### Для чего используется интерфейс?
Для уменьшения связанности кода

## Редко
-------------
### Как ты используешь интерфейс в работе?
В месте где объявляется обьект реализующий функционал объявляю интерфейс, в него добавляю все методы которые могут потребить извне. В месте где требуется такой объект опять объявляю интерфейс с нужными мне методами и работаю не с объектом а с интерфейсом. 

### Как в строготипизированным языке сделать функцию, которая работает с разными типами?
any - генерики или интерфейсы
    
### Зачем нужен пустой интерфейс?
для полиморфизма  (изменения работы программы в зависимости от разных входящих параметров)

### Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?
Не будет равно. Из-за таблицы методов

### Чем `any` отличается от пустого интерфейса?
ничем. any был добавлен для повышения удобства работы с кодом, но в функциональном плане он идентичен пустому интерфейсу 

### Чем пустой интерфейс отличается от пустой структуры?
Пустой интерфейс может содержать значения любого типа, пустая структура не может содержать никаких данных. 
Пустая структура занимает 0 байт, пустой интерфейс требует больше памяти, так как он хранит информацию о типе и значение.
Пустой интерфейс используется для работы с разными типами данных, пустая структура — для создания маркеров или использования в качестве ключей


# Общее
==============================

## Средне
-------------
### Какие преимущества есть у Golang?
Легковесные треды, строгая типизация, простота синтаксиса и простота работы с многопоточкой

## Редко
-------------
### Какие основные компоненты библиотеки runtime знаешь?
Планировщик, сборщик мусора, переменные среды (GOMAXPROC)

### Какие недостатки есть у Golang?
Сборщик мусора непресдказуем, сложная типизация - нет кастов

### Какая последняя версия Golang?
1.23 (1.22 stable)

### Расскажи про пакет reflect и как его используешь?
    
### Как передаются параметры в функцию, по ссылке или по значению?
ВСЕГДА по значения - происходит копирование (либо указателей либо значений)


# Планировщик
==============================

## Средне
-------------
### Как работает планировщик Golang?
Есть GMP модель.
Есть локальные и глобальные очереди. 
Есть кражи горутин и перераспределение нагрузки. 
Есть кооперативная модель и сейчас идёт переход на конкурентную 

## Редко
-------------
### Как работает вытесняющая многозадачность?
Вытесняющая многозадачность (preemptive multitasking) — это вид многозадачности, при котором планировщик задач принудительно приостанавливает выполнение текущей задачи и отдает управление другой задаче, готовой для исполнения. Приостановка текущей задачи называется вытеснением.


### За счет чего достигается параллельное выполнение в Golang? 
Модель GMP Go, включающая горутины, мьютексы и каналы , формирует основу его возможностей параллелизма. Горутины обеспечивают легкое параллельное выполнение, мьютексы обеспечивают безопасный доступ к общим ресурсам, а каналы обеспечивают связь и синхронизацию между горутинами.

### В чем разница между вытесняющим и кооперативным планировщиком? 
В кооперативной системе задача будет продолжаться до тех пор, пока она явно не откажется от управления ЦП. В упреждающей модели задачи могут быть принудительно приостановлены .
### Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?


### Может ли одна очередь украсть горутины у другой?


### Расскажи про глобальную и локальную очереди


### Сколько потоков операционной системы мы можем создать?
GOMAXPROC/количество ядер или виртуальных потоков

### Какой тип планировщика в Golang?
кооперативный но сейчас идёт переход на конк

### Какую функцию выполняет планировщик?


### Что происходит с горутиной при ее создании?




# Контекст
==============================
## Часто
-------------
### Для чего используется контекст?
Для передачи данных и контроля выполнения горутин (Timeout/Cancel)

ctx.Cancel()

## Средне
-------------
### Что такое контекст?
Структура данных для передачи данных и контроля выполнения горутин (Timeout/Cancel)

## Редко
-------------
### Как работает WithCancel?


### Как применяешь контекст в работе?

### Какие есть виды контекстов?
ctx.Background - от наследуются все контексты. И параллельно есть ctx.ToDo()

# defer
==============================
## Часто
-------------
### Что такое defer?
Функция отложенного вызова

## Средне
-------------
### Для чего используется defer?
Для отложенного вызова кода по окончании выполнения функции

### Какой порядок выполнения нескольких defer?
Обратный входы (аналог стека или обоймы)

## Редко
-------------
### Код в defer выполняется до return или после?
Он вычисляется в моменте (с копией всех входящих параметров) и выполняется после.

# Память
==============================

## Редко
-------------
### Как узнать где выделяется переменная, в стеке или куче?
escape analysis + общие принципы (10мб стека горутины)

### Как можно обнаружить чересчур большое выделение памяти?
pprof

### Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти?
переполнение и спираль смерти

### Расскажи про модель памяти в Golang, про стек и про кучу
стек и куча — это две области, в которых может быть выделена память. Стек обычно быстрее выделяется и удаляется, поскольку для этого нужно просто переместить указатель стека, но его размер также более ограничен. 
Куча больше, но выделяется и очищается медленнее и для освобождения неиспользуемой памяти требуется сборка мусора.

### Какое максимальный размер значения для размещения в стеке?


### Что такое Escape Analysis?
техника оптимизации компилятора для повышения производительности, определяет возможность безопасного выделения переменной в стек


### Что если при увеличении слайса полностью забьем память?
out of memory

### Что быстрее, размещение объектов в стеке или куче и почему?
в стеке, тк не требует сборки мусора

### Что такое утечка памяти?
перерасход оперативной памяти


# Типы данных
==============================

## Средне
-------------
### Какие типы данных есть в Golang?
Логический(bool), Целочисленные типы, Числа с плавающей запятой, Строковые типы, Указатели, Идентификационные типы, Абстрактные типы данных

## Редко
-------------
### Какой длины руна?
в завимости от кодировки

### Как реализовать Enum в Golang?
iota
const (
       Red = iota // 0
       Green // 1
       Blue    // 2
)

### Если нужно в строке хранить эмодзи, то как это сделать? 
сменить кодировку

### Что если во время компиляции переполним тип? В int8 запишем  256?
произойдёт запись с начала 0..255 -> 0 1

### Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?
запись с начала


# Гонка данных
==============================

## Средне
-------------
### Что такое race condition?
то ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации.

### Как обнаружить race condition?
инструменты golang - benchmark с флагом race

## Редко
-------------
### Флаг -race показывает гонку на этапе компиляции или выполнения?
компиляции


# Ошибки/Паника
==============================

## Редко
-------------
### Куда нужно помещать recover?
defer начало 

### Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
во всех местах где ошибка возможна - получать объект результата и объект ошибки, затем сравнивать с nil
НЕ ИСПОЛЬЗОВАТЬ панику вместо ошибок

### Какие есть функции для оборачивания и сравнения ошибок?
Сравнение типов (type assertion)
```golang
if errors.As(err, &target) {
    fmt.Println(target) // no model found for id
}
```

### Для чего используются ошибки, а для чего паника?
ошибки для всего где не нужна паника

### Для чего используется паника?
для экстренного выброса ошибки на самый верх стектрейса

### Что используется для обработки паники?
recover

### Что такое паника?
Критическая ошибка делающая невозможным дальнейшее выполнение программы (при этом есть некоторые ошибки которые даже через паник отловить невозможно)

# Указатели
==============================

## Средне
-------------
### Что такое указатель?
объект хранящий адрес ячейки памяти. За счёт того что мы знаем что это указатель - мы можем через него перейти к самому объекту средствами golang (разыменование)

# Дженерики
==============================

## Средне
-------------
### С дженериками работали?
да, работал, это средство обобщённого программирования

## Редко
-------------
### Чем кодогенерация отличается от дженериков?
ситуациями в которых их использовать - дженери позволяют статически обозначить в коде места в которых возможно обобщённое программирование. Кодогенерация позволяет создавать новые классы и методы через компиляцию. Можно сказать что дженерики - это встроенная в golang кодогенерация

### В какой версии появились дженерики?
1.18


# Конструкции
==============================

## Редко
-------------
### Гарантирует ли порядок выполнения конструкция select-case?
нет не гарантируется 
```golang
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
```

### Как выглядит конструкция утверждения типа switch?
```golang    
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
```

### Нужно ли в switch-case проставлять break?
нет, свитч отработает только раз

### Какие есть циклы в Golang?
только цикл for

### Чем отличается switch от select?
свитч работает с данными, а селект с каналами
свитч гарантирует порядок сравнений, селект работает случайно

# ООП
==============================

## Средне
-------------
### Как устроено ООП в Golang?
### Как реализуется наследование в Golang?
```golang
type StructA struct{
 Name string
}

type StructB struct{
 Name string
}
```
сравнить две реализации:
```golang
type StructC struct{
 A StructA
 B StructB
}

// ambiguous definition
// скорее всего golang не даст так сделать
type StructC struct{
 StructA
 StructB
}
```

# Сборщик мусора
==============================

## Редко
-------------
### Как приходилось работать со сборкой мусора?
```golang
debug.SetGCPercent(-1) // best practice - установить 80%
debug.SetMemoryLimit(math.MaxInt64)
```
### Как работает GC, его алгоритм и когда запускается?
Запускается по достижении порога по памяти. В момент запуска останавилвается вся программа. Работает по механизму mark-and-sweep

### Вот выделилась память и она используется, зачем в таком случае нужен GC?
Нам нужно больше памяти, а какая-то память уже вышла из употребления. Нужно произвести перераспределение

### Для чего используется GC?
Для автоматического анализа используемой и неиспользуемой памяти

### Какие есть рекомандации как упростить жизнь GC?
Стараться размещать данные на стеке

### Можно ли как-то отключить GC или ограничить запуски?
### Что такое GC?
### Что такое сборка мусора?


# Строки
==============================

## Средне
-------------
### Что такое string?
Массив хранящий внутри коды символов (55 - А, 77 - Z)

## Редко
-------------
### Приходит строка в utf8, там могут быть русские символы. Как узнать есть ли там русские буквы икак узнать длину в символах?
У каждой кодировки есть размер символа и методика шифрования. Через это можно определить

### Какие особенности есть у string?
Т.к. под капотом массив - строка иммутабельна. Для изменения или конкатенации большого количества строк следуюет использовать StrginBuilder/ByteBuilder


# Структуры
==============================

## Редко
-------------
### Имеет ли значение порядок полей в структуре?
если используется иота

### От чего зависит размер выравнивания в структуре?
### Что такое структура?


# Пакеты
==============================

## Редко
-------------
### Что такое пакет?

# Другие вопросы 
1. Как реализован перехват паники? - recovery, defer
2. Какие типы переменных имеют ссылочный тип? - указатели, срезы, ассоциативный массив, функции и каналы.
3. Как реализована многопоточность в go?
4. Чем горутина отличается от потока в других языках?
5. Сколько весят горутины на разных ОС?
6. Что такое дженерики?
7. Что такое контекст, какие есть виды?
8. Что делает функци init()? - выделяет фрагмент кода, который должен выполняться перед всеми другими частями пакета.
