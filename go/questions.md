# Типы данных
==============================
## Map
-------------
- Мапа это хэштаблица, которая хранит пары "ключ-значение", где каждому уникальному ключу соответствует определенное значение
- Ключи в мапе должны быть сравнимыми типами, например string, int, bool...
- под капотом хэш-функция для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.
- Бакет(Bucket/Slot) - структура данных, в которой хранятся ключи, значения и топхеш . Данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов
- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу

### Работа с map
- Мапа не потокобезопасна, но есть sync.Map (под капотом  RWMutex). При работе с мапой в конкурентном режиме, в частности, при записи, возникнет состояние гонки (race condition)
- Брать адрес элемента мапы не рекомендуется, тк это нарушит целостность данных - мапа не потокобезопасна (возможны ошибки - значение переместиться в другой участок памяти (бакет) или память вообще будет высвобождена и будет out of bounds)
- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;
- для удаления элемента вместо фактического удаления просто ячейка помечается пустой (0, nil)

### эвакуация данных в map
- Она начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.
- Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
Именно поэтому в структуре мапы есть свойство B — это степень двойки, которая показывает кол-во бакетов.
- Во время эвакуации данных, все операции мапы остаются доступны. Поэтому во многих частях исходного кода есть обращения как к buckets (новая структура бакетов, где их становится в 2 раза больше от текущего), так и к oldbuckets (текущение значение указателя buckets). После завершения копирования данных, oldbuckets становится равно nil.
- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.
- При росте мапы элементы переносятся в новые бакеты постепенно, а не все сразу

### сложность работы с map
- В лучшем случае - О(1), в худшем - О(n) (зависит от количества коллизий/хеш функции)
- константная сложность работы с мапой достигается за счёт хеш-таблицы

### коллизии в map
- Так как хэш-функция не идеальна, передав в нее два разных значения можно получить один и тот же результат. В случае с бакетами если - два разных значения положить в один и тот же бакет. 
- разрешение коллизий - выбирается один и тот же бакет и если происходит коллизия - создаётся новый бакет, который прилинковывается к первоначальному (аналог связного списка).
- как вариант, при большом количестве коллизий в мапе, можно переопределить хеш функцию у своих сравнимых структур ключа
- При коллизиях используется стратегия сlosed addressing (элементы хранятся с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, массив и др)

## Слайс
--------------------------------
- слайс это динамическая структура данных (может изменять свою длинну), надмножество массивов. Слайс создает массив, и при надобности расширяет его. *является ссылочным типом*
- слайс под капотом содержит указатель на исходный массив, каписити(емкость) и длину(количество элементов заданного типа)
- используется для хранения динамически меняющих свой размер массивов данных
- слайс не потокобезопасен

### Работа со слайсом
- append - В зависимости от текущих len/cap либо дописывает значение в текущий массив (возможна перезапись), либо создаёт новый массив х2 размера + подменяет указатель в слайсе + дописывает значение в новый массив
- Всегда передавать указатель на слайс, потому что может произойти пересоздание внутреннего массива и потеря указателя
- Нет полноценного удаления - по факту мы пересоздаём слайс меньшей длинны. А высвобождение данных лежит на исполнителе
- при создании слайса, если явно не указывать массив, который он будет использовать, Go выделяет память для него в куче. go tool compile -m
- сложность - O(n) - идёт полный перебор
- Если несколько горутин используют один и тот же слайс (например, передавая его между собой), то они могут избежать лишних аллокаций памяти. Вместо того чтобы создавать новые слайсы и массивы для каждой горутины, вы можете использовать один и тот же слайс, что экономит память и уменьшает нагрузку на сборщик мусора. Для предотвращения гонок данных можно использовать синхронизацию (например, мьютексы) или каналы для безопасного обмена данными между горутинами.

## Массив
-------------
- Массив имеет фиксированный размер и имеет фиксированное количество элементов. 
- Используется для хранения значений при условии что мы ГАРАНТИРОВАНО знаем что количество не будет меняться
- выделение памяти - при компиляции программы будет происходить escape анализ, при объявлении массива, память для него выделяется на стеке (если массив небольшой) или в куче (если массив большой или передается в функции).
- *передача по значению* в отличие от слайса, который является ссылочным типом
- Последовательный сегмент в памяти в каждой из ячеек которого (размер ячейки зависит от типа данных) хранятся значения. По факту массив - это указатель на начало последовательного сегмента, а обращение к каждой из его ячеек - это приплюсовывание к начальному указателю номера ячейки*размер.

# Каналы
==============================
![image](https://github.com/user-attachments/assets/81b1ed70-72e4-4eea-82ce-46cd306a336a)

- Канал - структура, созданная для передачи данных между горутинами. 
- Под капотом - ёмкость, список читателей, список писателей, буфер для обмена данными (1 в случае небуф, n в случае буферизованного).
- Буферизованые и небуферизованые. Однонаправленые и двунаправленые
- буферизованные - для пересылки массивов данных
- небуферизованные - для пересылки событий

### Чтение и запись в канал
- для неблокирующего чтения из канала используется select/range
- При чтении из закрытого канала будут считываться записанные значения, а когда они закончатся - дефолтные значения в зависимости от объявленного типа канала (в случае int-0, string-"")
- можно считать факт наличия значений в канале и проверить, закрыт канал или нет
- При чтении из небуферизованого канала - будет происходить копирование значения между стеками горутин.
- При чтении из буферизованого канала - будет происходить чтение из кучи, где размещён обменный массив канала.
- операции с каналами: запись, чтение, закрытие (close), создание (make)
- небуферизованый канал будет блокировать пишущие в него потоки пока ячейка для значения не опустошится (другая горутина не считает) для записи

# Примитивы синхронизации
==============================
- пакет sync хранят потокобезопасные структуры данных и примитивы сихнронизации потоков

## Atomic
- используются для ожидания выполнения горутин
- позволяет предоставить N горутин для доступа к общему ресурсу

## Mutex 
- позволяет организовать доступ к коду одновременно только одной горутине на запись
- контроль доступа к коду

## RWMutex
- обеспечивает контроль доступа к данным
- используется когда нужно разделить операции на читающие/записывающие
- при использовании на читающие не будет происходить блокировки

## WaitGroup
- используются для ожидания выполнения горутин wg.Wait()
- Ожидание выполнения параллельных задач (например обращение к 3 репозиториям)
- Под капотом счётчик который уменьшается/увеличивается через Add/Done

## lock

## sync.Map
- потокобезопасная мапа
- map под капотом RWMutex
- sync.Map начинает выигрывать в производительности от 4 ядер

## Pool

## Semaphore 
- позволяет организовать доступ к коду одновременно нескольким горутинам на запись
- позволяет предоставить N горутин для доступа к общему ресурсу

# Горутины
==============================
## Часто
-------------
### Что такое горутина?
- Это абстракция над потоками и процессорами в рамках которой мы исполняем наш код.
- Горутина может находиться в трех (основных) состояниях:
- Waiting: В этом состоянии, горутина бездействует. Например встает на паузу для операции с каналами или блокировками, либо может быть остановлена системным вызовом.
- Runnable: Горутина готова к тому чтобы быть исполненной, но еще не исполняется. Она ожидает своей очереди на потоке (M).
- Running: Горутина исполняется на потоке (M). Это будет продолжаться, пока работа не будет выполнена, или до тех пор, пока ее не прервет планировщик, либо что‑то еще ее не заблокирует.
- Горутины НЕ используются единожды и потом выбрасываются.
- Когда новая горутина инициируется, планировщик Go обращается к пулу горутин чтобы забрать одну, и если ни одной нет, то создает новую. Эта новая горутина добавляется в исполняемую очередь процесора (P).

### Чем горутина отличается от треда?
- Тред занимает больше памяти, горутина более легковесна. Тред управляется ядром системы, горутина - планировщиком GoLang

## Средне
-------------
### В чем преимущества горутин над тредами?
- Тред занимает больше памяти, горутина более лековесна. Тред управляется ядром системы, горутина - планировщиком GoLang

### Что есть в Golang для многопоточности?
- GMP модель, планировщик, каналы, пакет sync

## Редко
-------------
### Зачем понадобилось добавлять горутины в Golang?
Для поддержания большого кол-ва соеденений на сервере и более легковесного переключения контекста

### Как можно остановить горутину?
Она остановиться через 10мс после начала выполнения. Также можно передать в горутину объект контекста и задать TimeOut либо вызвать на этом объекте Cancel (ещё можно панику кинуть)

### Расскажите про конкуррентность и параллельность в Golang
GMP(PGM) модель
- P (processor) - логический процессор (не железо). Это условный контекст, который объединяет поток операционной системы (M) и очередь горутин. Количество горутин, привязанных к P неограниченно. По умолчанию количество P берётся из значения переменной среды GOMAXPROCS и равно количеству логических ядер компьютера.
- M (machine thread) - поток OS. Он закреплён за P и имеет с ним отношение один к одному.
- G (goroutine) - горутина
- В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (Global Run Queue - GRQ) и локальная очередь выполнения (Local Run Queue - LRQ). Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.
GRQ предназначен для горутин, которые еще не были назначены для какого-либо P.

### Когда возникает утечка горутины?
- Когда мы не закрываем внешнее взаимодействие (например файловый дескриптор)

### Какие есть способы связи между горутинами, какие плюсы и минусы?
- Каналы, внешние системы (шины данных например или тот же loopback порт)

# Интерфейсы
==============================
## Часто
-------------
### Что такое интерфейс?
Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. 

## Средне
-------------
### Как устроен интерфейс?
Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. 

### Для чего используется интерфейс?
Для уменьшения связанности кода

## Редко
-------------
### Как ты используешь интерфейс в работе?
В месте где объявляется обьект реализующий функционал объявляю интерфейс, в него добавляю все методы которые могут потребить извне. В месте где требуется такой объект опять объявляю интерфейс с нужными мне методами и работаю не с объектом а с интерфейсом. 

### Как в строготипизированным языке сделать функцию, которая работает с разными типами?
any - генерики или интерфейсы
    
### Зачем нужен пустой интерфейс?
для полиморфизма  (изменения работы программы в зависимости от разных входящих параметров)

### Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?
Не будет равно. Из-за таблицы методов

### Чем `any` отличается от пустого интерфейса?
ничем. any был добавлен для повышения удобства работы с кодом, но в функциональном плане он идентичен пустому интерфейсу 

### Чем пустой интерфейс отличается от пустой структуры?
Пустой интерфейс может содержать значения любого типа, пустая структура не может содержать никаких данных. 
Пустая структура занимает 0 байт, пустой интерфейс требует больше памяти, так как он хранит информацию о типе и значение.
Пустой интерфейс используется для работы с разными типами данных, пустая структура — для создания маркеров или использования в качестве ключей


# Общее
==============================

## Средне
-------------
### Какие преимущества есть у Golang?
Легковесные треды, строгая типизация, простота синтаксиса и простота работы с многопоточкой

## Редко
-------------
### Какие основные компоненты библиотеки runtime знаешь?
Планировщик, сборщик мусора, переменные среды (GOMAXPROC)

### Какие недостатки есть у Golang?
Сборщик мусора непресдказуем, сложная типизация - нет кастов

### Какая последняя версия Golang?
1.23 (1.22 stable)

### Расскажи про пакет reflect и как его используешь?
    
### Как передаются параметры в функцию, по ссылке или по значению?
ВСЕГДА по значения - происходит копирование (либо указателей либо значений)


# Планировщик
==============================

## Средне
-------------
### Как работает планировщик Golang?
Есть GMP модель.
Есть локальные и глобальные очереди. 
Есть кражи горутин и перераспределение нагрузки. 
Есть кооперативная модель и сейчас идёт переход на конкурентную 

## Редко
-------------
### Как работает вытесняющая многозадачность?
Вытесняющая многозадачность (preemptive multitasking) — это вид многозадачности, при котором планировщик задач принудительно приостанавливает выполнение текущей задачи и отдает управление другой задаче, готовой для исполнения. Приостановка текущей задачи называется вытеснением.


### За счет чего достигается параллельное выполнение в Golang? 
Модель GMP Go, включающая горутины, мьютексы и каналы , формирует основу его возможностей параллелизма. Горутины обеспечивают легкое параллельное выполнение, мьютексы обеспечивают безопасный доступ к общим ресурсам, а каналы обеспечивают связь и синхронизацию между горутинами.

### В чем разница между вытесняющим и кооперативным планировщиком? 
В кооперативной системе задача будет продолжаться до тех пор, пока она явно не откажется от управления ЦП. В упреждающей модели задачи могут быть принудительно приостановлены .
### Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?


### Может ли одна очередь украсть горутины у другой?


### Расскажи про глобальную и локальную очереди


### Сколько потоков операционной системы мы можем создать?
GOMAXPROC/количество ядер или виртуальных потоков

### Какой тип планировщика в Golang?
кооперативный но сейчас идёт переход на конк

### Какую функцию выполняет планировщик?


### Что происходит с горутиной при ее создании?




# Контекст
==============================
## Часто
-------------
### Для чего используется контекст?
Для передачи данных и контроля выполнения горутин (Timeout/Cancel)

ctx.Cancel()

## Средне
-------------
### Что такое контекст?
Структура данных для передачи данных и контроля выполнения горутин (Timeout/Cancel)

## Редко
-------------
### Как работает WithCancel?


### Как применяешь контекст в работе?

### Какие есть виды контекстов?
ctx.Background - от наследуются все контексты. И параллельно есть ctx.ToDo()

# defer
==============================
## Часто
-------------
### Что такое defer?
Функция отложенного вызова

## Средне
-------------
### Для чего используется defer?
Для отложенного вызова кода по окончании выполнения функции

### Какой порядок выполнения нескольких defer?
Обратный входы (аналог стека или обоймы)

## Редко
-------------
### Код в defer выполняется до return или после?
Он вычисляется в моменте (с копией всех входящих параметров) и выполняется после.

# Память
==============================

## Редко
-------------
### Как узнать где выделяется переменная, в стеке или куче?
escape analysis + общие принципы (10мб стека горутины)

### Как можно обнаружить чересчур большое выделение памяти?
pprof

### Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти?
переполнение и спираль смерти

### Расскажи про модель памяти в Golang, про стек и про кучу
стек и куча — это две области, в которых может быть выделена память. Стек обычно быстрее выделяется и удаляется, поскольку для этого нужно просто переместить указатель стека, но его размер также более ограничен. 
Куча больше, но выделяется и очищается медленнее и для освобождения неиспользуемой памяти требуется сборка мусора.

### Какое максимальный размер значения для размещения в стеке?


### Что такое Escape Analysis?
техника оптимизации компилятора для повышения производительности, определяет возможность безопасного выделения переменной в стек


### Что если при увеличении слайса полностью забьем память?
out of memory

### Что быстрее, размещение объектов в стеке или куче и почему?
в стеке, тк не требует сборки мусора

### Что такое утечка памяти?
перерасход оперативной памяти


# Типы данных
==============================

## Средне
-------------
### Какие типы данных есть в Golang?
Логический(bool), Целочисленные типы, Числа с плавающей запятой, Строковые типы, Указатели, Идентификационные типы, Абстрактные типы данных

## Редко
-------------
### Какой длины руна?
в завимости от кодировки

### Как реализовать Enum в Golang?
iota
const (
       Red = iota // 0
       Green // 1
       Blue    // 2
)

### Если нужно в строке хранить эмодзи, то как это сделать? 
сменить кодировку

### Что если во время компиляции переполним тип? В int8 запишем  256?
произойдёт запись с начала 0..255 -> 0 1

### Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?
запись с начала


# Гонка данных
==============================

## Средне
-------------
### Что такое race condition?
ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации.

### Как обнаружить race condition?
инструменты golang - benchmark с флагом race

## Редко
-------------
### Флаг -race показывает гонку на этапе компиляции или выполнения?
компиляции


# Ошибки/Паника
==============================

## Редко
-------------
### Куда нужно помещать recover?
defer начало 

### Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
во всех местах где ошибка возможна - получать объект результата и объект ошибки, затем сравнивать с nil
НЕ ИСПОЛЬЗОВАТЬ панику вместо ошибок

### Какие есть функции для оборачивания и сравнения ошибок?
Сравнение типов (type assertion)
```golang
if errors.As(err, &target) {
    fmt.Println(target) // no model found for id
}
```

### Для чего используются ошибки, а для чего паника?
ошибки для всего где не нужна паника

### Для чего используется паника?
для экстренного выброса ошибки на самый верх стектрейса

### Что используется для обработки паники?
recover

### Что такое паника?
Критическая ошибка делающая невозможным дальнейшее выполнение программы (при этом есть некоторые ошибки которые даже через паник отловить невозможно)

# Указатели
==============================

## Средне
-------------
### Что такое указатель?
объект хранящий адрес ячейки памяти. За счёт того что мы знаем что это указатель - мы можем через него перейти к самому объекту средствами golang (разыменование)

# Дженерики
==============================

## Средне
-------------
### С дженериками работали?
да, работал, это средство обобщённого программирования

## Редко
-------------
### Чем кодогенерация отличается от дженериков?
ситуациями в которых их использовать - дженери позволяют статически обозначить в коде места в которых возможно обобщённое программирование. Кодогенерация позволяет создавать новые классы и методы через компиляцию. Можно сказать что дженерики - это встроенная в golang кодогенерация

### В какой версии появились дженерики?
1.18


# Конструкции
==============================

## Редко
-------------
### Гарантирует ли порядок выполнения конструкция select-case?
нет не гарантируется 
```golang
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
```

### Как выглядит конструкция утверждения типа switch?
```golang    
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
```

### Нужно ли в switch-case проставлять break?
нет, свитч отработает только один раз

### Какие есть циклы в Golang?
только цикл for

### Чем отличается switch от select?
свитч работает с данными, а селект с каналами
свитч гарантирует порядок сравнений, селект работает случайно

### Что такое switch type?
// Golang program to illustrate the
// concept of type switches
var value interface{} = "GeeksforGeeks"
  
  // type switch to find 
  // out interface{} type
  switch t := value.(type){
  
    case int64:

      // if type is an integer
      fmt.Println("Type is an integer:", t)

    case string:

      // if type is a string
      fmt.Println("Type is a string:", t)

    case nil:

      // if type is nil (zero-value)
      fmt.Println("Type is nil.")
    default:

      // if type is other than above
      fmt.Println("Type is unknown!")
  }


# ООП
==============================

## Средне
-------------
### Как устроено ООП в Golang?
### Как реализуется наследование в Golang?
```golang
type StructA struct{
 Name string
}

type StructB struct{
 Name string
}
```
сравнить две реализации:
```golang
type StructC struct{
 A StructA
 B StructB
}

// ambiguous definition
// скорее всего golang не даст так сделать
type StructC struct{
 StructA
 StructB
}
```

# Сборщик мусора
==============================

## Редко
-------------
### Как приходилось работать со сборкой мусора?
```golang
debug.SetGCPercent(-1) // best practice - установить 80%
debug.SetMemoryLimit(math.MaxInt64)
```
### Как работает GC, его алгоритм и когда запускается?
Запускается по достижении порога по памяти. В момент запуска останавилвается вся программа. Работает по механизму mark-and-sweep

### Вот выделилась память и она используется, зачем в таком случае нужен GC?
Нам нужно больше памяти, а какая-то память уже вышла из употребления. Нужно произвести перераспределение

### Для чего используется GC?
Для автоматического анализа используемой и неиспользуемой памяти

### Какие есть рекомандации как упростить жизнь GC?
Стараться размещать данные на стеке

### Можно ли как-то отключить GC или ограничить запуски?
### Что такое GC?
### Что такое сборка мусора?


# Строки
==============================

## Средне
-------------
### Что такое string?
Массив хранящий внутри коды символов (55 - А, 77 - Z)

## Редко
-------------
### Приходит строка в utf8, там могут быть русские символы. Как узнать есть ли там русские буквы икак узнать длину в символах?
У каждой кодировки есть размер символа и методика шифрования. Через это можно определить

### Какие особенности есть у string?
Т.к. под капотом массив - строка иммутабельна. Для изменения или конкатенации большого количества строк следуюет использовать StrginBuilder/ByteBuilder


# Структуры
==============================

## Редко
-------------
### Имеет ли значение порядок полей в структуре?
если используется иота

### От чего зависит размер выравнивания в структуре?
### Что такое структура?


# Пакеты
==============================

## Редко
-------------
### Что такое пакет?

# Другие вопросы 
1. Как реализован перехват паники? - recovery, defer
2. Какие типы переменных имеют ссылочный тип? - указатели, срезы, ассоциативный массив, функции и каналы.
3. Как реализована многопоточность в go?
4. Чем горутина отличается от потока в других языках?
5. Сколько весят горутины на разных ОС?
6. Что такое дженерики?
7. Что такое контекст, какие есть виды?
8. Что делает функци init()? - выделяет фрагмент кода, который должен выполняться перед всеми другими частями пакета.
   
## БД
-------------
 ### Какие существуют виды индексов?
 1. B-Tree - бинарное дерево
 2. HASH - под капотом хэш-функция
 3. GiST - для работы с сложными типами данных: геометрические объекты, текст и массивы. Они позволяют быстро выполнять поиск по пространственным, текстовым и иерархическим данным.
 4. GIN - для полнотекстового поиска и поиска по массивам
 5. BRIN - для компактного представления больших объемов данных
 6. Составные индексы - создаются на основе нескольких колонок (больше 2х)
 
 ### типы join-ов и их отличия Left join и inner join
 ### типы изоляций транзакций, для чего нужны?
 ### как сделать дедлок в бд? 
 Циклическая зависимость
 ### Денормализация бд плюсы и минусы
