# Типы данных
==============================
## String
--------------------------------
- Массив хранящий внутри коды символов (55 - А, 77 - Z)
- У каждой кодировки есть размер символа и методика шифрования. Через это можно определить какие символы в строке
- Т.к. под капотом массив - строка иммутабельна. Для изменения или конкатенации большого количества строк следуюет использовать StrginBuilder/ByteBuilder
  
## Map
-------------
- Мапа это хэштаблица, которая хранит пары "ключ-значение", где каждому уникальному ключу соответствует определенное значение
- Ключи в мапе должны быть сравнимыми типами, например string, int, bool...
- под капотом хэш-функция для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.
- Бакет(Bucket/Slot) - структура данных, в которой хранятся ключи, значения и топхеш . Данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов
- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу

### Работа с map
- Мапа не потокобезопасна, но есть sync.Map (под капотом  RWMutex). При работе с мапой в конкурентном режиме, в частности, при записи, возникнет состояние гонки (race condition)
- Брать адрес элемента мапы не рекомендуется, тк это нарушит целостность данных - мапа не потокобезопасна (возможны ошибки - значение переместиться в другой участок памяти (бакет) или память вообще будет высвобождена и будет out of bounds)
- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;
- для удаления элемента вместо фактического удаления просто ячейка помечается пустой (0, nil)

### эвакуация данных в map
- Она начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.
- Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
Именно поэтому в структуре мапы есть свойство B — это степень двойки, которая показывает кол-во бакетов.
- Во время эвакуации данных, все операции мапы остаются доступны. Поэтому во многих частях исходного кода есть обращения как к buckets (новая структура бакетов, где их становится в 2 раза больше от текущего), так и к oldbuckets (текущение значение указателя buckets). После завершения копирования данных, oldbuckets становится равно nil.
- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.
- При росте мапы элементы переносятся в новые бакеты постепенно, а не все сразу

### сложность работы с map
- В лучшем случае - О(1), в худшем - О(n) (зависит от количества коллизий/хеш функции)
- константная сложность работы с мапой достигается за счёт хеш-таблицы

### коллизии в map
- Так как хэш-функция не идеальна, передав в нее два разных значения можно получить один и тот же результат. В случае с бакетами если - два разных значения положить в один и тот же бакет. 
- разрешение коллизий - выбирается один и тот же бакет и если происходит коллизия - создаётся новый бакет, который прилинковывается к первоначальному (аналог связного списка).
- как вариант, при большом количестве коллизий в мапе, можно переопределить хеш функцию у своих сравнимых структур ключа
- При коллизиях используется стратегия сlosed addressing (элементы хранятся с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, массив и др)

## Слайс
--------------------------------
- слайс это динамическая структура данных (может изменять свою длинну), надмножество массивов. Слайс создает массив, и при надобности расширяет его. *является ссылочным типом*
- слайс под капотом содержит указатель на исходный массив, каписити(емкость) и длину(количество элементов заданного типа)
- используется для хранения динамически меняющих свой размер массивов данных
- слайс не потокобезопасен

### Работа со слайсом
- append - В зависимости от текущих len/cap либо дописывает значение в текущий массив (возможна перезапись), либо создаёт новый массив х2 размера + подменяет указатель в слайсе + дописывает значение в новый массив
- Всегда передавать указатель на слайс, потому что может произойти пересоздание внутреннего массива и потеря указателя
- Нет полноценного удаления - по факту мы пересоздаём слайс меньшей длинны. А высвобождение данных лежит на исполнителе
- при создании слайса, если явно не указывать массив, который он будет использовать, Go выделяет память для него в куче. go tool compile -m
- сложность - O(n) - идёт полный перебор
- Если несколько горутин используют один и тот же слайс (например, передавая его между собой), то они могут избежать лишних аллокаций памяти. Вместо того чтобы создавать новые слайсы и массивы для каждой горутины, вы можете использовать один и тот же слайс, что экономит память и уменьшает нагрузку на сборщик мусора. Для предотвращения гонок данных можно использовать синхронизацию (например, мьютексы) или каналы для безопасного обмена данными между горутинами.
- если при увеличении слайса полностью забьется память будет out of memory

## Массив
-------------
- Массив имеет фиксированный размер и имеет фиксированное количество элементов. 
- Используется для хранения значений при условии что мы ГАРАНТИРОВАНО знаем что количество не будет меняться
- выделение памяти - при компиляции программы будет происходить escape анализ, при объявлении массива, память для него выделяется на стеке (если массив небольшой) или в куче (если массив большой или передается в функции).
- *передача по значению* в отличие от слайса, который является ссылочным типом
- Последовательный сегмент в памяти в каждой из ячеек которого (размер ячейки зависит от типа данных) хранятся значения. По факту массив - это указатель на начало последовательного сегмента, а обращение к каждой из его ячеек - это приплюсовывание к начальному указателю номера ячейки*размер.

## Каналы
-------------
![image](https://github.com/user-attachments/assets/81b1ed70-72e4-4eea-82ce-46cd306a336a)

- Канал - структура, созданная для передачи данных между горутинами. 
- Под капотом - ёмкость, список читателей, список писателей, буфер для обмена данными (1 в случае небуф, n в случае буферизованного).
- Буферизованые и небуферизованые. Однонаправленые и двунаправленые
- буферизованные - для пересылки массивов данных
- небуферизованные - для пересылки событий

### Чтение и запись в канал
- для неблокирующего чтения из канала используется select/range
- При чтении из закрытого канала будут считываться записанные значения, а когда они закончатся - дефолтные значения в зависимости от объявленного типа канала (в случае int-0, string-"")
- можно считать факт наличия значений в канале и проверить, закрыт канал или нет 
```
value, ok := <-ch
	if !ok {
	// Если ok == false, значит канал закрыт
	fmt.Println("Канал закрыт")
	break
}
```
- операции с каналами: запись, чтение, закрытие (close), создание (make)
  
### небуферизованный канал
- При чтении из небуферизованого канала - будет происходить копирование значения между стеками горутин, которые читают/пишут.
- небуферизованый канал будет блокировать пишущие в него потоки пока ячейка для значения не опустошится (другая горутина не считает) для записи

### буферизованный канал
- При чтении из буферизованого канала - будет происходить чтение из кучи, где размещён обменный массив канала, куда горутины будут ходить
- буферизованный канал не блокирует пишущие в него потоки

## Интерфейс
-------------
- Структура хранящая под капотом таблицу заявленных методов и указатель на объект реализующий их. Даже пустой интерфейс НИКОГДА не будет nil
- используется для уменьшения связанности кода

### интерфейс в работе
- В месте где объявляется обьект реализующий функционал объявляю интерфейс, в него добавляю все методы которые могут потребить извне. В месте где требуется такой объект опять объявляю интерфейс с нужными мне методами и работаю не с объектом а с интерфейсом. 
- функцию, которая работает с разными типами - switch type
- пустой интерфейс нужен для полиморфизма (изменения работы программы в зависимости от разных входящих параметров)
- any был добавлен для повышения удобства работы с кодом, но в функциональном плане он идентичен пустому интерфейсу 

### пустой интерфейс и пустая структура
- Пустой интерфейс может содержать значения любого типа, пустая структура не может содержать никаких данных. 
- Пустая структура занимает 0 байт, пустой интерфейс требует больше памяти, так как он хранит информацию о типе и значение.
- Пустой интерфейс используется для работы с разными типами данных, пустая структура — для создания маркеров или использования в качестве ключей

# конкурентность и параллельность в Golang
==============================
- GMP модель, планировщик, каналы, горутины, пакет sync

## пакет sync
-------------
- пакет sync хранит потокобезопасные структуры данных и примитивы сихнронизации потоков
  
### Atomic
- используется для ожидания выполнения горутин
- позволяет предоставить N горутин для доступа к общему ресурсу

### Mutex 
- позволяет организовать доступ к коду одновременно только одной горутине на запись
- контроль доступа к коду

### RWMutex
- обеспечивает контроль доступа к данным
- используется когда нужно разделить операции на читающие/записывающие
- при использовании на читающие не будет происходить блокировки

### WaitGroup
- используются для ожидания выполнения горутин wg.Wait()
- Ожидание выполнения параллельных задач (например обращение к 3 репозиториям)
- Под капотом счётчик который уменьшается/увеличивается через Add/Done

### lock

### sync.Map
- потокобезопасная мапа
- используется в специфических кейсах с использованием 200+ горутин, идет выигрывание по скорости
- map под капотом RWMutex
- sync.Map начинает выигрывать в производительности от 4 ядер

### Pool

### Semaphore 
- позволяет организовать доступ к коду одновременно нескольким горутинам на запись
- позволяет предоставить N горутин для доступа к общему ресурсу

## Горутины
-------------
- Это абстракция над потоками и процессорами в рамках которой мы исполняем наш код.
- Горутина может находиться в трех (основных) состояниях:
- Waiting: В этом состоянии, горутина бездействует. Например встает на паузу для операции с каналами или блокировками, либо может быть остановлена системным вызовом.
- Runnable: Горутина готова к тому чтобы быть исполненной, но еще не исполняется. Она ожидает своей очереди на потоке (M).
- Running: Горутина исполняется на потоке (M). Это будет продолжаться, пока работа не будет выполнена, или до тех пор, пока ее не прервет планировщик, либо что‑то еще ее не заблокирует.
- Горутины НЕ используются единожды и потом выбрасываются.
- Когда новая горутина инициируется, планировщик Go обращается к пулу горутин чтобы забрать одну, и если ни одной нет, то создает новую. Эта новая горутина добавляется в исполняемую очередь процесора (P).
- преимущество горутин над тредами в том, что тред занимает больше памяти, горутина более лековесна. Тред управляется ядром системы, горутина - планировщиком GoLang
- нужны для поддержания большого кол-ва соединений на сервере и более легковесного переключения контекста
- горутина остановится через 10мс после начала выполнения. Также можно передать в горутину объект контекста и задать TimeOut либо вызвать на этом объекте Cancel (ещё можно панику кинуть)
- утечка горутины возникает, когда не закрывается внешнее взаимодействие (например файловый дескриптор)
- горутины общаются между собой через каналы, внешние системы (шины данных или loopback порт)


## GMP(PGM) модель
-------------
- P (processor) - логический процессор (не железо). Это условный контекст, который объединяет поток операционной системы (M) и очередь горутин. Количество горутин, привязанных к P неограниченно. По умолчанию количество P берётся из значения переменной среды GOMAXPROCS и равно количеству логических ядер компьютера.
- M (machine thread) - поток OS. Он закреплён за P и имеет с ним отношение один к одному.
- G (goroutine) - горутина
- В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (Global Run Queue - GRQ) и локальная очередь выполнения (Local Run Queue - LRQ). Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.
GRQ предназначен для горутин, которые еще не были назначены для какого-либо P.

### локальная и глобальная очередь

- Глобальная и локальная очереди в модели GMP языка Go позволяют эффективно управлять конкурентностью и параллелизмом, минимизируя накладные расходы на синхронизацию и обеспечивая высокую производительность. Это делает Go особенно подходящим для разработки высокопроизводительных и масштабируемых приложений.

### Глобальная очередь
- Определение: Глобальная очередь — это очередь, в которой хранятся все горутины, ожидающие выполнения. Она доступна для всех потоков и используется для управления горутинами, которые не были назначены на выполнение.
- Использование: Когда горутина создается, она помещается в глобальную очередь. Если локальная очередь потока пуста, планировщик может взять горутину из глобальной очереди и назначить ее на выполнение.
- Проблемы: Глобальная очередь может стать узким местом, если много горутин ожидают выполнения, так как доступ к ней требует синхронизации, что может привести к накладным расходам.

### Локальная очередь
- Определение: Локальная очередь — это очередь, которая принадлежит конкретному потоку (OS thread). Каждая горутина, запланированная на выполнение в этом потоке, добавляется в его локальную очередь.
- Использование: Когда планировщик назначает горутину на выполнение, он сначала проверяет локальную очередь. Если в локальной очереди есть горутины, они будут выполнены без необходимости обращения к глобальной очереди. Это уменьшает накладные расходы на синхронизацию и повышает производительность.
- Преимущества: Локальные очереди позволяют уменьшить конкуренцию за ресурсы и ускоряют выполнение горутин, так как потоки могут обрабатывать свои локальные очереди без блокировок.

### Принцип работы
- Создание горутин: Когда вы создаете новую горутину, она помещается в глобальную очередь.
- Планирование: Планировщик проверяет локальные очереди потоков. Если локальная очередь пуста, он берет горутину из глобальной очереди и помещает её в локальную очередь потока.
- Выполнение: Поток выполняет горутины из своей локальной очереди. Если он завершает выполнение всех горутин в своей локальной очереди, он снова обращается к глобальной очереди для получения новых задач.
- Устранение блокировок: Если горутина блокируется (например, ожидает на канале), планировщик может переместить другую горутину из локальной или глобальной очереди для выполнения в этом потоке.


# преимущества и недостатки Golang
==============================
- В целом, Go является отличным выбором для разработки высокопроизводительных серверных приложений и микросервисов, но его особенности могут не подойти для всех типов проектов.
- последняя версия Golang 1.23 (1.22 stable)

## Преимущества:
-------------
- Простота и читаемость: Go имеет лаконичный синтаксис, что делает код более понятным и легким для чтения.
- Высокая производительность: Go компилируется в машинный код, что обеспечивает высокую скорость выполнения программ.
- Параллелизм: Встроенная поддержка горутин и каналов позволяет легко создавать конкурентные приложения.
- Статическая типизация: Статическая типизация помогает избежать многих ошибок на этапе компиляции, что повышает надежность кода.
- Стандартная библиотека: Go предлагает мощную стандартную библиотеку, которая включает в себя множество полезных пакетов для работы с сетью, файловой системой и другими задачами.
- Кроссплатформенность: Go позволяет компилировать приложения для различных операционных систем и архитектур с минимальными усилиями.
- Инструменты для разработки: Go поставляется с набором инструментов для форматирования кода, тестирования и управления зависимостями.

## Недостатки:
-------------
- Отсутствие generics (до версии 1.18): Ранее Go не поддерживал обобщенные типы, что ограничивало гибкость кода. Однако эта проблема была решена в версии 1.18.
- Меньше библиотек и фреймворков: По сравнению с языками, такими как Python или Java, экосистема Go может быть менее обширной.
- Упрощенная обработка ошибок: В Go нет встроенного механизма исключений, что может привести к избыточному коду для обработки ошибок.
- Отсутствие поддержки наследования: Go использует композицию вместо наследования, что может быть непривычно для разработчиков, привыкших к объектно-ориентированным языкам.
- Сложности с интерфейсами: Хотя интерфейсы в Go мощные, их использование может быть не интуитивно понятным для новичков.
- Долгое время компиляции: Для крупных проектов время компиляции может быть заметным, хотя это не всегда критично.




## Редко
-------------
### Какие основные компоненты библиотеки runtime знаешь?
Планировщик, сборщик мусора, переменные среды (GOMAXPROC)

    
### Как передаются параметры в функцию, по ссылке или по значению?
ВСЕГДА по значения - происходит копирование (либо указателей либо значений)



## Средне
-------------

## Редко
-------------
### Как работает вытесняющая многозадачность?
Вытесняющая многозадачность (preemptive multitasking) — это вид многозадачности, при котором планировщик задач принудительно приостанавливает выполнение текущей задачи и отдает управление другой задаче, готовой для исполнения. Приостановка текущей задачи называется вытеснением.


### За счет чего достигается параллельное выполнение в Golang? 
Модель GMP Go, включающая горутины, мьютексы и каналы , формирует основу его возможностей параллелизма. Горутины обеспечивают легкое параллельное выполнение, мьютексы обеспечивают безопасный доступ к общим ресурсам, а каналы обеспечивают связь и синхронизацию между горутинами.

### В чем разница между вытесняющим и кооперативным планировщиком? 
В кооперативной системе задача будет продолжаться до тех пор, пока она явно не откажется от управления ЦП. В упреждающей модели задачи могут быть принудительно приостановлены .
### Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?


### Может ли одна очередь украсть горутины у другой?




### Сколько потоков операционной системы мы можем создать?
GOMAXPROC/количество ядер или виртуальных потоков

### Какую функцию выполняет планировщик?


### Что происходит с горутиной при ее создании?







# Память
==============================

## Редко
-------------
### Как узнать где выделяется переменная, в стеке или куче?
escape analysis + общие принципы (10мб стека горутины)

### Как можно обнаружить чересчур большое выделение памяти?
pprof

### Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти?
переполнение и спираль смерти

### Расскажи про модель памяти в Golang, про стек и про кучу
стек и куча — это две области, в которых может быть выделена память. Стек обычно быстрее выделяется и удаляется, поскольку для этого нужно просто переместить указатель стека, но его размер также более ограничен. 
Куча больше, но выделяется и очищается медленнее и для освобождения неиспользуемой памяти требуется сборка мусора.

### Какое максимальный размер значения для размещения в стеке?


### Что такое Escape Analysis?
техника оптимизации компилятора для повышения производительности, определяет возможность безопасного выделения переменной в стек




### Что такое утечка памяти?
перерасход оперативной памяти


# Типы данных
==============================

## Средне
-------------
### Какие типы данных есть в Golang?
Логический(bool), Целочисленные типы, Числа с плавающей запятой, Строковые типы, Указатели, Идентификационные типы, Абстрактные типы данных

## Редко
-------------
### Какой длины руна?
в завимости от кодировки

### Как реализовать Enum в Golang?
iota
const (
       Red = iota // 0
       Green // 1
       Blue    // 2
)

### Если нужно в строке хранить эмодзи, то как это сделать? 
сменить кодировку

### Что если во время компиляции переполним тип? В int8 запишем  256?
произойдёт запись с начала 0..255 -> 0 1

### Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?
запись с начала


# Гонка данных
==============================

## Средне
-------------
### Что такое race condition?
ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации.

### Как обнаружить race condition?
инструменты golang - benchmark с флагом race

## Редко
-------------
### Флаг -race показывает гонку на этапе компиляции или выполнения?
компиляции


# Ошибки/Паника
==============================



### Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
во всех местах где ошибка возможна - получать объект результата и объект ошибки, затем сравнивать с nil
НЕ ИСПОЛЬЗОВАТЬ панику вместо ошибок

### Какие есть функции для оборачивания и сравнения ошибок?
Сравнение типов (type assertion)
```golang
if errors.As(err, &target) {
    fmt.Println(target) // no model found for id
}
```

### Для чего используются ошибки, а для чего паника?
ошибки для всего где не нужна паника

### Для чего используется паника?
для экстренного выброса ошибки на самый верх стектрейса

### Что используется для обработки паники?
recover

### Что такое паника?
Критическая ошибка делающая невозможным дальнейшее выполнение программы (при этом есть некоторые ошибки которые даже через паник отловить невозможно)

# Указатели
==============================

## Средне
-------------
### Что такое указатель?
объект хранящий адрес ячейки памяти. За счёт того что мы знаем что это указатель - мы можем через него перейти к самому объекту средствами golang (разыменование)

# Дженерики
==============================

## Средне
-------------
### С дженериками работали?
да, работал, это средство обобщённого программирования

## Редко
-------------
### Чем кодогенерация отличается от дженериков?
ситуациями в которых их использовать - дженери позволяют статически обозначить в коде места в которых возможно обобщённое программирование. Кодогенерация позволяет создавать новые классы и методы через компиляцию. Можно сказать что дженерики - это встроенная в golang кодогенерация

### В какой версии появились дженерики?
1.18


# Конструкции
==============================

## Редко
-------------
### Гарантирует ли порядок выполнения конструкция select-case?
нет не гарантируется 
```golang
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
```

### Как выглядит конструкция утверждения типа switch?
```golang    
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
```

### Нужно ли в switch-case проставлять break?
нет, свитч отработает только один раз


### Чем отличается switch от select?
свитч работает с данными, а селект с каналами
свитч гарантирует порядок сравнений, селект работает случайно

### Что такое switch type?
// Golang program to illustrate the
// concept of type switches
var value interface{} = "GeeksforGeeks"
  
  // type switch to find 
  // out interface{} type
  switch t := value.(type){
  
    case int64:

      // if type is an integer
      fmt.Println("Type is an integer:", t)

    case string:

      // if type is a string
      fmt.Println("Type is a string:", t)

    case nil:

      // if type is nil (zero-value)
      fmt.Println("Type is nil.")
    default:

      // if type is other than above
      fmt.Println("Type is unknown!")
  }


# ООП
==============================

## Средне
-------------
### Как устроено ООП в Golang?
### Как реализуется наследование в Golang?
```golang
type StructA struct{
 Name string
}

type StructB struct{
 Name string
}
```
сравнить две реализации:
```golang
type StructC struct{
 A StructA
 B StructB
}

// ambiguous definition
// скорее всего golang не даст так сделать
type StructC struct{
 StructA
 StructB
}
```






# Структуры
==============================

## Редко
-------------
### Имеет ли значение порядок полей в структуре?
если используется иота

### От чего зависит размер выравнивания в структуре?
### Что такое структура?


# Основные функции

## defer
- используется для отложенного вызова кода по окончании выполнения функции, например defer wg.Done() для ожидания работы всех горутин
- порядок выполнения нескольких defer - обратный
- код в defer вычисляется в моменте (с копией всех входящих параметров) и выполняется после return
- применяется в recover для отлова паники (помещаектся в начало)
- **Паника возникает до вызова defer**

### defer не вызывается
- При обработке ошибок, или в любом другом случае, когда мы вызывается os.Exit()
- при log.Fatal(), т.к. внутри неё также прячется os.Exit()

### recover()
Внутри отложенной функции вызывается recover(), чтобы попытаться восстановить выполнение программы. Если паника произошла, recover() вернет значение, вызвавшее панику.

```
// Функция для отлова паники
func safeFunction() {
	// Отложенная функция для восстановления
	defer func() {
		if r := recover(); r != nil {
			// Обработка паники
			fmt.Println("Паника поймана:", r)
		}
	}()

	// Код, который может вызвать панику
	fmt.Println("Выполняем безопасную функцию...")
	causePanic() // Вызов функции, которая вызывает панику
	fmt.Println("Эта строка не будет выполнена") // Эта строка не выполнится
}

// Функция, вызывающая панику
func causePanic() {
	panic("Что-то пошло не так!")
}

func main() {
	safeFunction()
	fmt.Println("Программа продолжает выполнение после отлова паники.")
}
```






# Основные пакеты

## errors

## context
- Пакет context в Go предоставляет механизм для передачи значений, отмены и дедлайнов (временных ограничений) между горутинами. Он особенно полезен для управления длительными операциями, такими как сетевые запросы, операции ввода-вывода и другие задачи, которые могут занять неопределенное время.
- Пакет context является мощным инструментом для управления горутинами и асинхронными операциями в Go. Он позволяет более эффективно управлять временем выполнения, отменой операций и передачей данных между горутинами, что делает его важным для разработки надежных приложений.
  
### Основные функции пакета context:
- Передача данных: Вы можете передавать значения между различными функциями и горутинами.
- Отмена: Вы можете отменить выполнение операций, если они больше не нужны.
- Дедлайны: Вы можете установить временные ограничения на выполнение операций.
- 
### Применение:
- В веб-серверах для отмены запросов, если клиент отключается.
- В фоновых задачах, чтобы избежать выполнения долгих операций, если они больше не нужны.
- Для управления зависимостями между горутинами.
  
### Примеры использования пакета context
- Пример 1: Использование контекста для отмены операции
```
// Создаем контекст с отменой
ctx, cancel := context.WithCancel(context.Background()) // создание контекст с отменой
defer cancel() // Убедимся, что cancel вызывается в конце

go func() {
// Имитация длительной операции
	time.Sleep(2 * time.Second)
	fmt.Println("Длительная операция завершена")
	cancel() // Отмена контекста
}()

// Ожидание завершения операции
select {
	case <-ctx.Done(): fmt.Println("Операция была отменена:", ctx.Err())
	case <-time.After(3 * time.Second): fmt.Println("Операция завершена без отмены")
}
```

- Пример 2: Использование контекста с дедлайном
``` 
// Создаем контекст с дедлайном
ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))
defer cancel() // Убедимся, что cancel вызывается в конце

go func() {
	// Имитация длительной операции
	time.Sleep(2 * time.Second)
	fmt.Println("Длительная операция завершена")
}()

// Ожидание завершения операции
select {
	case <-ctx.Done(): fmt.Println("Операция завершилась с ошибкой:", ctx.Err())
	case <-time.After(3 * time.Second): fmt.Println("Операция завершена без отмены")
}
```

## reflect

## runtime

# Планировщик
- тип планировщика - кооперативный, но сейчас идёт переход на конкурирующий
- GMP модель.
- локальные и глобальные очереди. 
- кражи горутин и перераспределение нагрузки. 


# сборщик мусора/GC
==============================

```
debug.SetGCPercent(-1) // best practice - установить 80%
debug.SetMemoryLimit(math.MaxInt64)
```
- GC запускается по достижении порога по памяти. В момент запуска останавливается вся программа. Работает по механизму mark-and-sweep
- При необходимости выделения дополнительной памяти, при том, что какая-то память уже вышла из употребления. GC производит перераспределение
- GC служит для автоматического анализа используемой и неиспользуемой памяти
- можно оптимизировать работу GC если размещать данные на стеке

# переменные среды (GOMAXPROC)
- для понимания, сколько потоков операционной системы можно создать
- GOMAXPROC/количество ядер или виртуальных потоков


# Другие вопросы 
2. Какие типы переменных имеют ссылочный тип? - указатели, срезы, ассоциативный массив, функции и каналы.
3. Как реализована многопоточность в go?
4. Чем горутина отличается от потока в других языках?
5. Сколько весят горутины на разных ОС?
6. Что такое дженерики?
7. Что такое контекст, какие есть виды?
8. Что делает функци init()? - выделяет фрагмент кода, который должен выполняться перед всеми другими частями пакета.
   
## БД
-------------
 ### Какие существуют виды индексов?
 1. B-Tree - бинарное дерево
 2. HASH - под капотом хэш-функция
 3. GiST - для работы с сложными типами данных: геометрические объекты, текст и массивы. Они позволяют быстро выполнять поиск по пространственным, текстовым и иерархическим данным.
 4. GIN - для полнотекстового поиска и поиска по массивам
 5. BRIN - для компактного представления больших объемов данных
 6. Составные индексы - создаются на основе нескольких колонок (больше 2х)
 
 ### типы join-ов и их отличия Left join и inner join
 ### типы изоляций транзакций, для чего нужны?
 ### как сделать дедлок в бд? 
 Циклическая зависимость
 ### Денормализация бд плюсы и минусы
