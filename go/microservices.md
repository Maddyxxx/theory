
### синхронное взаимодействие
- HTTP/rpc
- при операциях, когда ожидается что время ожидания невелико/объём работ невелик
- быстрые проверки

### асинхронное взаимодействие
- протокол AMQP (взаимодействие на базе сообщений)
- шины данных
- Преимущество асинхронного типа связи в том, что запрос клиента обрабатывается сразу, в то время, как при синхронной модели вся обработка выполняется одновременно. Поэтому синхронный способ взаимодействия лучше не использовать в рамках исходной операции «запрос-ответ».
- при операциях, когда ожидается большое или долгое количество операций или требуется уведомить сразу много сервисов одним сообщением
- асинхронно можно кидать уведомления о приёмке заказа и обогащённые данные заказа для обработки группой воркеров
- сообщение о высылке заказа курьером можно передавать в шину асинхронно, а уже из шины сервис пуш-уведомлений примет его и переправит покупателю

### HTTP (HyperText Transfer Protocol)
HTTP – это протокол передачи информации в интернете, который расшифровывается как «протокол передачи гипертекста» . Например, браузер отправляет единичный запрос на сервер,
который в свою очередь обрабатывает его, формирует ответ и делится с браузером этим ответом – ресурсами в виде данных
### REST
- концепция (архитектура) для организации взаимодействия между независимыми объектами (приложениями) посредством протокола HTTP. 
- Включает в себя набор принципов (рекомендаций) взаимодействия клиент-серверных приложений. 
- Обычно представлен в формате JSON

### RPC

### Шины данных
- Шины данных - способ асинхронного общения между сервисами, позволяющий относительно легко снизить связность системы и масштабировать систему.
- Самые популярные в порядке убывания: Kafka, RabbitMQ, Azure Service Bus, Amzn SQS, NATS
- Суть в реализации паттерна publisher-subscriber: есть сервисы производящие сообщения и потребляющие (это может быть даже 1 сервис)
- Шины предоставляют функционал:
1) хранения (действуя как база)
2) распределения (действуя как маршрутизатор)
3) масштабирования (обеспечивая канал доставки)
- При этом 2 самые популярные шины (Kafka и RabbitMQ) отличаются концептуально
RabbitMQ - умная шина, которая отслеживает доставку сообщения и стучась в сервисы напрямую
Kafka - журнал, в который сервисы сами должны ходить за новыми сообщениями.
- RabbitMQ ориентирован на нагрузки ~10k RPS, используется чаще всего для распространения сигналов и лёгких событий не требующих долгого хранения
Kafka выдерживает нагрузки вплоть до 600k RPS, а при грамотной настройке возможно и больше (через создание тн кластеров). За счёт  постоянного хранения сообщений на дисках - используется для операций сам факт доставки которых безумно важен (напр финансовые операции или изменения балансов)
- Ключевые понятия:
Topic - логическое объединение партиций
Partition - последовательность сообщений в журнале
Offset  - смещение относительно начала журнала, точка последнего чтения
Partitioning Key - ключ (префикс) по которому идёт распределение сообщений по партициям
Producer
Consumer
Consumer Group - объединение потребителей в единую группу для перераспределения нагрузки при чтении партиций
Cluster

- Ещё есть режимы режимы работы доставки сообщений:
-- возможно один (0...1)
-- как минимум один (1...100)
-- точно один (1)

-- Первый режим самый пососный, второй используется когда на стороне сервиса есть проверки идемпотентности и тогда можно снизить нагрузку на кафку
-- Третий режим самый топовый но за счёт того что кафка должна сравнивать сообщения между собой возрастает нагрузка на неё и снижается пропускная способность

- метрики снимаются на разных уровнях:
-- уровень фронта - клики по иконкам, событий, граф переходов
-- уровень инфры - CPU utilization, CPU average, RAM usage, container healthcheck-и, сетевой входящий и исходящий поток
-- уровень кода - количество входящих, время задержки, время обработки, количество используемых горутин

- ОТДЕЛЬНО стоит анализ приложения на основе логов - на любом из уровней можно снимать статистику с логов и на её основе строить анализ (точнее смотреть структурное логирование)

### профилирование приложения:
- go benchmark  - тестовый прогон программы (НЕЛЬЗЯ ПОЛАГАТЬСЯ - в проде программа может себя вести иначе)
- go benchmark -race - анализ кода на наличие race condition-ов и
- go tool pprof (пример go tool pprof -svg ./perftest00.test ./cpu.out > cpu.svg) - составление стека вызовов (и дальнейший его экспорт например в svg). Также используется для профилирования приложений в проде (при этом не мешает работе за счёт не постоянного мониторинга а снятия сэмплов исполнения)
- все эти инструменты хороши но недостаточны для понимания нюансов работы приложения (например изза ошибок на внешних системах). Процесс отладки и тестирования итеративный - следует применять все перечисленные инструменты + метрики + логгирование, и даже так будут инциденты
