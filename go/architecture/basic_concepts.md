Двухфазный коммит (2PC)
-----------------------------------
 -  Протокол двухфазного коммита гарантирует согласованность и атомарность в распределенных транзакциях.  Обеспечивая, что либо все узлы зафиксируют транзакцию, либо ни один, протокол предотвращает частичные обновления и поддерживает согласованность распределенных баз данных. Это позволяет избежать нежелательного результата, когда транзакция фиксируется в одном узле системы, но прерывается на другом.

SAGA (хореография/окрестрация)
-----------------------------------
 - Saga позволяет создавать более надежные, гибкие и устойчивые системы, способные успешно справляться с реальными вызовами микросервисной архитектуры. Saga позволяет создавать высококачественные приложения, которые предоставляют безупречный опыт пользователя и обеспечивают стабильную работу в условиях постоянно меняющегося окружения.
 - Orchestration-based Saga: Этот подход базируется на использовании централизованного координатора (оркестратора), который управляет выполнением саги и отправляет запросы на выполнение шагов каждому микросервису. Подход «через оркестрацию» облегчает реализацию и отслеживание саги, так как всю логику координации можно вынести в отдельный сервис.
 - Choreography-based Saga: Этот подход подходит для сценариев, где сага включает большое количество микросервисов. Он основан на использовании событийной модели и асинхронной коммуникации между сервисами с помощью брокеров сообщений. Подход «через хореографию» позволяет каждому микросервису знать, какие действия выполняются другими сервисами, и соответственно реагировать на изменения состояния системы.

OUTBOX
-----------------------------------
 - Паттерн Outbox обеспечивает сохранение сообщений в хранилище данных (как правило, в таблице outbox в базе данных), прежде чем они будут в конечном итоге переданы в брокер сообщений. Если бизнес-объект и соответствующие сообщения сохраняются в рамках одной транзакции базы данных, это гарантирует, что данные не будут потеряны. Либо будет зафиксировано все, либо при возникновении ошибки произойдет полный откат. Здесь гарантируется атомарность.
 - Outbox решает проблему связи между сервисами. Теперь не нужно беспокоиться, что брокер или сервис доставки будут недоступны. Все сообщения сохраняются в базу и будут обработаны, когда недоступные сервисы оживут.
 - Сообщения отправляются, только когда транзакция базы данных коммитится
 - Этот паттерн помогает обеспечить согласованность данных между микросервисами и уменьшить вероятность потери сообщений при сбоях.
 - Outbox часто используется в связке с паттерном Saga, так как оба этих паттерна направлены на решение проблемы консистентности данных в микросервисной архитектуре.


Группы доступности

Сетевое взаимодействие:
Модель OSI (Open Systems Interconnection)
-----------------------------------
 - Это эталонная модель, разработанная для описания функций телекоммуникационных или вычислительных систем, необходимых для сетевого взаимодействия. Она разделяет процесс сетевого взаимодействия на семь взаимосвязанных уровней. Каждый уровень выполняет специфические функции и взаимодействует с уровнями непосредственно выше и ниже.
 - Уровень 1: физический уровень определяет электрические и физические характеристики соединения данных. Он отвечает за обмен физическими сигналами между физическими устройствами и аппаратурами.
 - Уровень 2: канальный уровень предназначен для обеспечения взаимодействия сетей на физическом уровне и контроля ошибок, которые могут возникнуть. также решает проблему адресации при передаче информации. Канальный уровень обычно делится на два подуровня - уровень media access control (MAC) layer и logical link control (LLC) . Уровень MAC отвечает за управление тем, как устройства в сети получают доступ к мультимедиа и разрешение на передачу данных. Уровень LLC отвечает за идентификацию и инкапсуляцию протоколов сетевого уровня, а также контролирует проверку ошибок и синхронизацию кадров.
 - Уровень 3: сетевой уровень обрабатывает маршрутизацию пакетов через логическую адресацию и функции коммутации.
 - Уровень 4: транспортный уровень обеспечивает функции и средства передачи последовательностей данных от источника к хосту назначения через одну или несколько сетей, сохраняя при этом функции quality of service (QoS) и обеспечивая полную доставку данных. также может предоставить явную функцию управления потоком. Наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации. Для передачи данных, наиболее чувствительных к задержкам, используется протокол UDP, позволяющий организовать связь без установки соединения. 
 - Уровень 5: сеансовый уровень управляет диалогами (соединениями) между компьютерами. Он устанавливает, управляет, сохраняет и в конечном итоге разрывает соединения между локальным и удаленным приложением. также выполняет функции аутентификации и авторизации. Он проверяет, что данные также доставляются. Сеансовый уровень обычно реализуется явно в прикладных средах, которые используют удаленные вызовы процедур. Например, во время видеосвязи необходимо, чтобы два потока данных (аудио и видео) шли синхронно. Когда к разговору двоих человек прибавится третий — получится уже конференция. Задача пятого уровня — сделать так, чтобы собеседники могли понять, кто сейчас говорит.
 - Уровень 6: уровень представления проверяет данные, чтобы обеспечить его совместимость с коммуникационными ресурсами. Он переводит данные в форму, что прикладной уровень и более низкие уровни принимают. Уровень представления обеспечивает преобразование протоколов и кодирование/декодирование данных. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8. На этом уровне может осуществляться сжатие/распаковка или шифрование/дешифрование, а также перенаправление запросов другому сетевому ресурсу, если они не могут быть обработаны локально.
 - Уровень 7: прикладной уровень напрямую взаимодействует с применениями программных обеспечений для предоставления необходимых функций связи, и он наиболее близок к конечным пользователям. Функции прикладного уровня обычно включают в себя проверку доступности коммуникационных партнеров и ресурсов для поддержки любой передачи данных. Другими словами, все услуги, получаемые седьмым уровнем от других, используются для доставки данных до пользователя. Этот уровень также определяет протоколы для конечных применений, такие как domain name system (DNS), file transfer protocol (FTP), hypertext transfer protocol (HTTP), Internet message access protocol (IMAP), post office protocol (POP), simple mail transfer protocol (SMTP), Simple Network Management Protocol (SNMP), и Telnet (a terminal emulation).

RPC (Remote Procedure Call):
-----------------------------------
 - Протокол взаимодействия между клиентом и сервером, который позволяет клиенту вызывать процедуры (функции, методы) на удаленном сервере, как если бы они были локальными. Это обеспечивает абстракцию взаимодействия по сети и позволяет программам работать в распределенной среде, скрывая сложности передачи данных и выполнения удаленных операций.
 - Примеры: gRPC, SOAP, JSON-RPC.
 - Процессы сериализации и десериализации обеспечивают преобразование данных между форматами, понятными клиенту и серверу.

HTTP
-----------------------------------
HTTP-сообщения представляют собой обычный текст, поэтому неавторизованные лица могут легко получить к ним доступ и прочитать их через Интернет. 
HTTPS - передает все данные в зашифрованном виде.
 - HTTP — протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов 
 - HTTP расшифровывается как HyperText Transfer Protocol, «протокол передачи гипертекста». В соответствии со спецификацией OSI, HTTP является протоколом прикладного (верхнего, 7-го) уровня. Актуальная на данный момент версия протокола, HTTP 1.1

HTTP 1.1, 1.2, 2.0, 3.0 ключевые отличия
-----------------------------------
 - HTTP1 -> HTTP2
Первая версия протокола http требовала дожидаться получения ответа перед отправлением следующего запроса в рамках одного соединения. Во второй версии протокола - это исправили, соединение может использоваться без ожидания завершения уже отправленного запроса.
 - HTTP2 -> HTTP3/QUIC
Проблема блокировки была решена в версии 2 — но только на уровне http протокола. На транспортном уровне tcp она все еще есть в виде обязательного последовательного получения пакетов. Поэтому версию 3 собрали на протоколе udp, в которой этой особенности нет, и назвали это QUIC. В один запрос упаковано установление соединения и установление шифрования.
 - в HTTP3 при разрыве соединения не нужно устанавливать новое, то есть не будет повторных рукопожатий, так как используется уникальный идентификатор соединения.
Websocket

UPD и TCP
-----------------------------------
 - UPD (User Datagram Protocol). Этот протокол используется для «связи без установки соединения». Один узел сети просто отсылает пакеты, адресуя их другому узлу. Отправитель не знает ничего о том, готов ли получатель к приёму пакетов, и вообще, существует ли этот получатель. Отправитель также не ждёт какого-либо подтверждения о том, что получатель принял предыдущие пакеты.
 - Заголовок UDP-пакета состоит из 8 байт, которые включают в себя: порт отправителя, порт получателя, длину датаграммы, контрольную сумму.
 - TCP (Transmission Control Protocol) — это протокол управления передачей. В отличие от протокола UDP следит за тем, чтобы данные были получены в правильной форме и порядке и осуществляет повторный запрос данных в случае их потери. Это повышает надежность за счет увеличения времени задержки. TCP – сложный и требующий установку соединения. Перед тем, как начать передачу данных, клиент и сервер должны подключиться друг к другу и договориться о том, как они будут осуществлять эту самую передачу.
 - заголовок TCP состоит как минимум из 20 байт, а то и больше. Он включает в себя: порт отправителя, порт получателя, порядковый номер, номер подтверждения, длину заголовка, флаги, размер окна, контрольную сумму, указатель важности, дополнительные опции.
 - Ключевым различием между TCP и UDP является скорость, поскольку TCP сравнительно медленнее UDP. В целом, UDP является быстрым, простым и эффективным протоколом, однако повторная передача потерянных пакетов данных возможна только в TCP.
 - UDP «легче» и проще, чем TCP, но в то же время UDP не такой надёжный, как TCP

количество подключений к базе данных (забитие портов)
-----------------------------------
 - Каждое подключение требует ресурсов (памяти, процессорного времени). Если количество подключений превышает допустимый предел, это может привести к замедлению работы базы данных и увеличению времени отклика. Влияние на производительность
 - Если слишком много соединений открыто, это может привести к исчерпанию доступных портов (забитие портов). В результате новые подключения могут не устанавливаться, что может вызвать сбои в работе приложений.
 - Избыточное количество подключений может быть признаком атаки (например, DDoS-атаки). Контроль позволяет быстрее выявлять и реагировать на такие угрозы.
 - Ограничение числа подключений помогает избежать ситуации, когда база данных перегружена и не может обслуживать запросы от других пользователей или приложений.

▎Примеры:
 - Веб-приложение: Если у вас есть веб-приложение, которое обрабатывает много пользователей одновременно, и у базы данных нет ограничения на количество подключений, то при резком увеличении нагрузки (например, во время распродажи) база данных может не справиться с количеством запросов, что приведет к сбоям.
 - Мобильное приложение: Если мобильное приложение постоянно открывает новые соединения с базой данных без их закрытия, это может привести к исчерпанию доступных соединений и невозможности работы приложения для новых пользователей.
 - Системы мониторинга: В системах мониторинга или аналитики, где происходит постоянный опрос базы данных, важно контролировать количество подключений, чтобы избежать перегрузки и обеспечить стабильную работу системы.
